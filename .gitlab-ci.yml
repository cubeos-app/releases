# =============================================================================
# CubeOS Release Image Pipeline
# =============================================================================
# Builds flashable ARM64 images (Full + Lite) from the golden base image.
#
# WORKFLOW (build once, release later):
#   1. Push to main  → build-image runs (~20 min each), uploads to Package Registry
#   2. Verify green  → test the images if needed
#   3. Tag (git tag v0.1.0-alpha.10 && git push --tags)
#      → release jobs run (~2 min), create GitLab + GitHub releases
#      → NO rebuild — release jobs download the already-built images
#
# VARIANTS:
#   Full: All services + offline content (docsindex, dozzle, kiwix, curated apps)
#   Lite: Core services only (pihole, npm, hal, api, dashboard, registry, terminal)
#
# SINGLE JOB BUILD: Everything runs in one container to avoid transferring
# 1.5GB+ of Docker image tarballs as CI artifacts between stages.
#
# PREREQUISITES:
#   1. Golden base image in Package Registry (cubeos-base/1.1.0)
#   2. CI variables: GHCR_USER, GHCR_TOKEN (for private GHCR images)
#   3. CI variable: GHCR_TOKEN (used for both GHCR pushes and GitHub API releases)
#   4. Token access: releases project allowed to access coreapps project
#
# TIME: ~20 minutes per variant (build) + ~2 minutes (release on tag)
# =============================================================================

stages:
  - build
  - release

variables:
  CUBEOS_VERSION: "0.2.0-beta.01"
  BASE_VERSION: "3.0.0"
  BASE_IMAGE_NAME: "cubeos-base-ubuntu24.04.3-arm64"
  GITHUB_REPO: "cubeos-app/releases"

# =============================================================================
# Build Release Image (Full + Lite variants via parallel matrix)
# =============================================================================
build-image:
  stage: build
  image:
    name: mkaczanowski/packer-builder-arm:latest
    entrypoint: [""]
  parallel:
    matrix:
      - CUBEOS_VARIANT: "full"
        IMAGE_SIZE: "12G"
      - CUBEOS_VARIANT: "lite"
        IMAGE_SIZE: "10G"
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "push"'
    - if: '$CI_PIPELINE_SOURCE == "web"'
  script:
    - |
      set -e

      # ── Compute variant-specific IMAGE_NAME ──────────────────────────
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-arm64"
      else
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-arm64"
      fi
      export IMAGE_NAME
      echo "VARIANT=${CUBEOS_VARIANT} IMAGE_NAME=${IMAGE_NAME} IMAGE_SIZE=${IMAGE_SIZE}"

      echo "============================================================"
      echo "  CubeOS Release Pipeline — Phase 0: Setup (${CUBEOS_VARIANT})"
      echo "============================================================"

      # Validate CI variables
      if [ -z "${GHCR_USER:-}" ] || [ -z "${GHCR_TOKEN:-}" ]; then
        echo "ERROR: GHCR_USER and GHCR_TOKEN CI variables are required."
        echo "Set them in: Settings > CI/CD > Variables"
        exit 1
      fi
      echo "GHCR auth: ${GHCR_USER}"

      # QEMU binfmt
      mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc || true
      if [ ! -f /proc/sys/fs/binfmt_misc/qemu-aarch64 ]; then
        echo "ERROR: QEMU aarch64 binfmt not registered on host!"
        exit 1
      fi
      echo "QEMU aarch64 binfmt: OK"

      # Install tools
      echo "Installing tools..."
      # Refresh APT keys if stale (packer-builder-arm image may have outdated Ubuntu Jammy keyring)
      apt-get update -q 2>&1 | tail -3 || {
        echo "WARN: apt-get update failed — refreshing GPG keys..."
        apt-key adv --refresh-keys --keyserver keyserver.ubuntu.com 2>&1 | tail -3 || true
        rm -rf /var/lib/apt/lists/*
        apt-get update -q 2>&1 | tail -3
      }
      apt-get install -y -q docker.io skopeo xz-utils zerofree e2fsprogs parted wget kpartx util-linux curl jq git zstd 2>&1 | tail -5
      echo "  skopeo $(skopeo --version 2>/dev/null | head -1)"
    - |
      set -e
      # Re-export IMAGE_NAME (each script block is a new shell)
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-arm64"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-arm64"; fi
      export IMAGE_NAME

      echo ""
      echo "============================================================"
      echo "  Phase 0a: Clone coreapps repo (${CUBEOS_VARIANT})"
      echo "============================================================"

      git clone --depth 1 \
        "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/products/cubeos/coreapps.git" \
        /tmp/coreapps-src

      # Lite variant: only core services
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        SERVICES="pihole npm cubeos-api cubeos-hal cubeos-dashboard registry terminal"
      else
        SERVICES="pihole npm cubeos-api cubeos-hal cubeos-dashboard cubeos-docsindex registry dozzle terminal kiwix filebrowser chromadb"
      fi

      mkdir -p coreapps-bundle
      for svc in $SERVICES; do
        if [ -d "/tmp/coreapps-src/${svc}/appconfig" ]; then
          mkdir -p "coreapps-bundle/${svc}"
          cp -r "/tmp/coreapps-src/${svc}/appconfig" "coreapps-bundle/${svc}/"
          echo "  + ${svc}/appconfig"
        else
          echo "  - ${svc} (not found or no appconfig)"
        fi
      done

      if [ -d "/tmp/coreapps-src/scripts" ]; then
        cp -r /tmp/coreapps-src/scripts coreapps-bundle/
        chmod +x coreapps-bundle/scripts/*.sh 2>/dev/null || true
        echo "  + scripts/"
      fi

      echo ""
      echo "Coreapps bundle:"
      find coreapps-bundle -type f | sort
      rm -rf /tmp/coreapps-src
      echo "Coreapps bundle: OK"

      # Clone docs repo for offline filesystem mode (T05)
      # B05: Try GitHub first, then GitLab, then mark as unavailable (04-cubeos.sh has fallback)
      echo ""
      echo "  Cloning docs repo for offline access..."
      DOCS_CLONED=false
      git clone --depth=1 https://github.com/cubeos-app/docs.git /tmp/cubeos-docs-src 2>&1 | tail -3 && \
        DOCS_CLONED=true && echo "  + docs repo cloned from GitHub" || \
        echo "  - GitHub docs clone failed, trying GitLab..."
      if [ "$DOCS_CLONED" = "false" ]; then
        git clone --depth=1 \
          "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/products/cubeos/docs.git" \
          /tmp/cubeos-docs-src 2>&1 | tail -3 && \
          DOCS_CLONED=true && echo "  + docs repo cloned from GitLab" || \
          echo "  - GitLab docs clone also failed (non-fatal, 04-cubeos.sh has placeholder fallback)"
      fi
      if [ -d /tmp/cubeos-docs-src ]; then
        mkdir -p coreapps-bundle/docs
        # Copy .md files only (exclude .git and other artifacts)
        find /tmp/cubeos-docs-src -maxdepth 2 -name '*.md' -exec cp {} coreapps-bundle/docs/ \; 2>/dev/null || true
        rm -rf /tmp/cubeos-docs-src
        DOCS_COUNT=$(find coreapps-bundle/docs -name '*.md' 2>/dev/null | wc -l)
        echo "  + ${DOCS_COUNT} docs bundled into coreapps-bundle/docs/"
      fi
    - |
      set -e
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-arm64"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-arm64"; fi
      export IMAGE_NAME

      echo ""
      echo "============================================================"
      echo "  Phase 0b: Download ARM64 Docker images (${CUBEOS_VARIANT})"
      echo "============================================================"

      mkdir -p docker-images
      IMG_COUNT=0

      # ── Core images (both variants) ──────────────────────────────────
      echo "[core] Pi-hole..."
      skopeo copy --override-arch arm64 --override-os linux --retry-times 3 \
        docker://docker.io/pihole/pihole:latest \
        docker-archive:docker-images/pihole.tar:pihole/pihole:latest
      IMG_COUNT=$((IMG_COUNT + 1))
      sleep 2

      echo "[core] Nginx Proxy Manager..."
      skopeo copy --override-arch arm64 --override-os linux --retry-times 3 \
        docker://docker.io/jc21/nginx-proxy-manager:latest \
        docker-archive:docker-images/npm.tar:jc21/nginx-proxy-manager:latest
      IMG_COUNT=$((IMG_COUNT + 1))
      sleep 2

      echo "[core] CubeOS API..."
      skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" \
        --override-arch arm64 --override-os linux --retry-times 3 \
        docker://ghcr.io/cubeos-app/api:latest \
        docker-archive:docker-images/cubeos-api.tar:ghcr.io/cubeos-app/api:latest
      IMG_COUNT=$((IMG_COUNT + 1))
      sleep 2

      echo "[core] CubeOS HAL..."
      skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" \
        --override-arch arm64 --override-os linux --retry-times 3 \
        docker://ghcr.io/cubeos-app/hal:latest \
        docker-archive:docker-images/cubeos-hal.tar:ghcr.io/cubeos-app/hal:latest
      IMG_COUNT=$((IMG_COUNT + 1))
      sleep 2

      echo "[core] CubeOS Dashboard..."
      skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" \
        --override-arch arm64 --override-os linux --retry-times 3 \
        docker://ghcr.io/cubeos-app/dashboard:latest \
        docker-archive:docker-images/cubeos-dashboard.tar:ghcr.io/cubeos-app/dashboard:latest
      IMG_COUNT=$((IMG_COUNT + 1))
      sleep 2

      echo "[core] Docker Registry..."
      skopeo copy --override-arch arm64 --override-os linux --retry-times 3 \
        docker://docker.io/library/registry:2 \
        docker-archive:docker-images/registry.tar:library/registry:2
      IMG_COUNT=$((IMG_COUNT + 1))
      sleep 2

      # ── Full-only images ─────────────────────────────────────────────
      if [ "$CUBEOS_VARIANT" = "full" ]; then
        echo "[full] CubeOS DocsIndex..."
        skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" \
          --override-arch arm64 --override-os linux --retry-times 3 \
          docker://ghcr.io/cubeos-app/cubeos-docsindex:latest \
          docker-archive:docker-images/cubeos-docsindex.tar:ghcr.io/cubeos-app/cubeos-docsindex:latest
        IMG_COUNT=$((IMG_COUNT + 1))

        echo "[full] Dozzle..."
        skopeo copy --override-arch arm64 --override-os linux --retry-times 3 \
          docker://docker.io/amir20/dozzle:latest \
          docker-archive:docker-images/dozzle.tar:amir20/dozzle:latest
        IMG_COUNT=$((IMG_COUNT + 1))

        echo "[full] Dufs (file browser)..."
        skopeo copy --override-arch arm64 --override-os linux --retry-times 3 \
          docker://docker.io/sigoden/dufs:latest \
          docker-archive:docker-images/dufs.tar:sigoden/dufs:latest
        IMG_COUNT=$((IMG_COUNT + 1))

        echo "[full] ChromaDB..."
        skopeo copy --override-arch arm64 --override-os linux --retry-times 3 \
          docker://docker.io/chromadb/chroma:latest \
          docker-archive:docker-images/chromadb.tar:chromadb/chroma:latest
        IMG_COUNT=$((IMG_COUNT + 1))
      else
        echo "[lite] Skipping full-only images (docsindex, dozzle, dufs, chromadb)"
      fi

      echo ""
      ls -lh docker-images/
      du -sh docker-images/
      echo "Docker images: OK (${IMG_COUNT} images for ${CUBEOS_VARIANT} variant)"
    - |
      set -e
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-arm64"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-arm64"; fi
      export IMAGE_NAME

      echo ""
      echo "============================================================"
      echo "  Phase 0b2: Download curated app images + ZIM content (${CUBEOS_VARIANT})"
      echo "============================================================"

      # Lite variant: skip curated apps and ZIM content entirely
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        echo "Lite variant: skipping curated images and ZIM content"
        mkdir -p curated-images  # empty dir so later phases don't fail
        echo "Phase 0b2: SKIPPED (lite)"
      else

      # --- Curated app images (for local registry) ---
      chmod +x skopeo/download-curated.sh
      # B56: Curated downloads MUST succeed. If kiwix-serve or ttyd fail to
      # download, Phase 1c silently skips ("No curated images found") and the
      # image ships with broken services showing 0/1 replicas.
      # B66: Enable verbose mode for CI debugging. Use set +e to capture
      # exit code without set -e killing the block prematurely.
      export CURATED_VERBOSE=true
      set +e
      ./skopeo/download-curated.sh curated-images
      CURATED_EXIT=$?
      set -e
      if [ "$CURATED_EXIT" -ne 0 ]; then
        echo "ERROR: Curated image download failed (exit $CURATED_EXIT)"
        echo "Cannot build image with broken curated apps."
        echo "Check network connectivity and image ARM64 manifests."
        echo ""
        echo "Debug: verify ARM64 manifests exist:"
        echo "  skopeo inspect --raw docker://ghcr.io/kiwix/kiwix-serve:3.8.1 | jq '.manifests[].platform'"
        echo "  skopeo inspect --raw docker://docker.io/tsl0922/ttyd:latest | jq '.manifests[].platform'"
        exit 1
      fi
      echo ""
      echo "Curated tarballs:"
      ls -lh curated-images/ 2>/dev/null || echo "  (no curated images)"
      # B66: Verify expected tarball count matches manifest entries
      EXPECTED_COUNT=$(grep -v '^[[:space:]]*#' skopeo/curated-apps.txt | grep -v '^$' | wc -l)
      ACTUAL_COUNT=$(ls curated-images/*.tar 2>/dev/null | wc -l)
      echo "  Expected: ${EXPECTED_COUNT} tarballs, Got: ${ACTUAL_COUNT}"
      if [ "$ACTUAL_COUNT" -lt "$EXPECTED_COUNT" ]; then
        echo "ERROR: Missing curated tarballs (${ACTUAL_COUNT}/${EXPECTED_COUNT})"
        exit 1
      fi

      # --- ZIM content for Kiwix (configurable) ---
      ZIM_ENABLED="${ZIM_ENABLED:-true}"
      ZIM_URL="${ZIM_URL:-https://download.kiwix.org/zim/wikipedia/wikipedia_en_100_maxi_2026-01.zim}"

      if [ "$ZIM_ENABLED" = "true" ]; then
        mkdir -p zim-content
        ZIM_FILENAME=$(basename "$ZIM_URL")
        echo "Downloading ZIM: ${ZIM_FILENAME}..."
        if wget -q --show-progress -O "zim-content/${ZIM_FILENAME}" "$ZIM_URL"; then
          echo "  ZIM OK: $(du -h "zim-content/${ZIM_FILENAME}" | cut -f1)"
        else
          echo "  WARN: ZIM download failed (non-fatal — Kiwix will show empty library)"
          rm -f "zim-content/${ZIM_FILENAME}"
        fi
      else
        echo "ZIM download disabled (ZIM_ENABLED=false)"
      fi
      echo "Phase 0b2: OK"
      fi  # end full-only curated/ZIM block
    - |
      set -e
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-arm64"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-arm64"; fi
      export IMAGE_NAME

      echo ""
      echo "============================================================"
      echo "  Phase 0c: Download golden base image"
      echo "============================================================"

      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           -o cubeos-base.img.xz \
           --connect-timeout 30 \
           --max-time 3600 \
           --retry 3 \
           --retry-delay 10 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos-base/${BASE_VERSION}/${BASE_IMAGE_NAME}.img.xz"
      ls -lh cubeos-base.img.xz
      echo "Base image: OK"
    - |
      set -e
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-arm64"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-arm64"; fi
      export IMAGE_NAME

      echo ""
      echo "============================================================"
      echo "  Phase 1: Packer build (${CUBEOS_VARIANT})"
      echo "  Started: $(date -u +%H:%M:%S)"
      echo "============================================================"

      chmod +x packer/scripts/*.sh firstboot/*.sh

      packer build \
        -var "version=${CUBEOS_VERSION}" \
        -var "variant=${CUBEOS_VARIANT}" \
        -var "image_size=${IMAGE_SIZE}" \
        -var "base_image_url=file://${CI_PROJECT_DIR}/cubeos-base.img.xz" \
        -var "base_image_checksum_type=none" \
        packer/cubeos.pkr.hcl

      ls -lh ${IMAGE_NAME}.img
      echo "Packer build: OK ($(date -u +%H:%M:%S))"
    - |
      set -e
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-arm64"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-arm64"; fi
      export IMAGE_NAME

      echo ""
      echo "============================================================"
      echo "  Phase 1b: Pre-load Docker images into image (${CUBEOS_VARIANT})"
      echo "  Started: $(date -u +%H:%M:%S)"
      echo "============================================================"

      # ── Step 1: Mount the built image ──────────────────────────────
      LOOPDEV=$(losetup -fP --show ${IMAGE_NAME}.img)
      echo "Loop device: $LOOPDEV"
      sleep 2

      ROOT_PART="${LOOPDEV}p2"
      if [ ! -b "$ROOT_PART" ]; then
        echo "ERROR: Root partition ${ROOT_PART} not found"
        losetup -d "$LOOPDEV"
        exit 1
      fi

      mkdir -p /mnt/cubeos-image
      mount "$ROOT_PART" /mnt/cubeos-image
      echo "Mounted root partition at /mnt/cubeos-image"

      # Ensure /var/lib/docker exists on the image
      mkdir -p /mnt/cubeos-image/var/lib/docker

      # ── Step 2: Start temporary dockerd ────────────────────────────
      # Key flags for isolation from any existing daemon:
      #   --data-root     → writes to the MOUNTED IMAGE, not the CI host
      #   -H              → separate socket to avoid conflicts
      #   --pidfile       → separate PID file
      #   --exec-root     → separate runtime state
      #   --iptables=false --bridge=none → no host networking changes
      #   --containerd=""  → don't connect to containerd (avoid socket conflicts)
      echo "Starting temporary dockerd with --data-root /mnt/cubeos-image/var/lib/docker..."

      dockerd \
        --data-root /mnt/cubeos-image/var/lib/docker \
        --storage-driver overlay2 \
        -H unix:///tmp/cubeos-preload.sock \
        --pidfile /tmp/cubeos-preload.pid \
        --exec-root /tmp/cubeos-preload-exec \
        --iptables=false \
        --bridge=none \
        --containerd="" \
        &>/tmp/dockerd-preload.log &
      DOCKERD_PID=$!

      echo "Waiting for dockerd (PID: $DOCKERD_PID)..."
      for i in $(seq 1 60); do
        if docker -H unix:///tmp/cubeos-preload.sock info &>/dev/null; then
          echo "  dockerd ready (${i}s)"
          break
        fi
        if [ "$i" -eq 60 ]; then
          echo "ERROR: dockerd failed to start. Log:"
          tail -30 /tmp/dockerd-preload.log
          kill "$DOCKERD_PID" 2>/dev/null || true
          umount /mnt/cubeos-image 2>/dev/null || true
          losetup -d "$LOOPDEV" 2>/dev/null || true
          exit 1
        fi
        sleep 1
      done

      # ── Step 3: Load ARM64 tarballs ────────────────────────────────
      DOCKER_CMD="docker -H unix:///tmp/cubeos-preload.sock"
      LOADED=0
      FAILED=0

      for tarball in docker-images/*.tar; do
        [ -f "$tarball" ] || continue
        NAME=$(basename "$tarball" .tar)
        SIZE=$(du -h "$tarball" | cut -f1)
        echo "  Loading: ${NAME} (${SIZE})..."
        LOAD_START=$(date +%s)

        if $DOCKER_CMD load < "$tarball" 2>&1; then
          LOAD_END=$(date +%s)
          echo "    OK ($(( LOAD_END - LOAD_START ))s)"
          LOADED=$((LOADED + 1))
        else
          echo "    FAILED"
          FAILED=$((FAILED + 1))
        fi
      done

      # ── Step 3b: Load curated images + retag for localhost:5000 ─────
      # B85: Compose services (terminal, future curated apps) use
      # --pull never and reference images as localhost:5000/{repo}:{tag}.
      # Phase 1c pushes these to the registry, but --pull never won't
      # query the registry. We must also have them in Docker's local
      # image cache with the localhost:5000/ prefix tag.
      # Lite variant: skip curated images (only core images loaded).
      echo ""
      CURATED_LOADED=0
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        echo "  Lite variant: skipping curated image loading"
      else
      echo "  Loading curated images into Docker cache (B85 fix)..."
      for tarball in curated-images/*.tar; do
        [ -f "$tarball" ] || continue
        NAME=$(basename "$tarball" .tar)
        SIZE=$(du -h "$tarball" | cut -f1)
        echo "  Loading curated: ${NAME} (${SIZE})..."

        if $DOCKER_CMD load < "$tarball" 2>&1; then
          echo "    Loaded"
          CURATED_LOADED=$((CURATED_LOADED + 1))
        else
          echo "    FAILED (non-fatal — image will be in registry)"
        fi
      done

      # Retag curated images with localhost:5000/ prefix
      # (compose files reference localhost:5000/{repo}:{tag})
      if [ "$CURATED_LOADED" -gt 0 ] && [ -f skopeo/curated-apps.txt ]; then
        echo "  Retagging curated images for localhost:5000/..."
        while IFS= read -r line; do
          [[ "$line" =~ ^[[:space:]]*# ]] && continue
          [[ -z "${line// }" ]] && continue

          SOURCE_IMAGE=$(echo "$line" | cut -d'|' -f1 | xargs)
          TAG=$(echo "$line" | cut -d'|' -f2 | xargs)
          REPO_NAME=$(echo "$SOURCE_IMAGE" | sed 's|^docker\.io/||; s|^ghcr\.io/||')

          if $DOCKER_CMD tag "${REPO_NAME}:${TAG}" "localhost:5000/${REPO_NAME}:${TAG}" 2>/dev/null; then
            echo "    ${REPO_NAME}:${TAG} → localhost:5000/${REPO_NAME}:${TAG}"
          else
            echo "    WARN: Could not retag ${REPO_NAME}:${TAG} (image may not have loaded)"
          fi
        done < skopeo/curated-apps.txt
      fi
      fi  # end full-only curated block

      # ── Step 3c: Retag core images for localhost:5000 ─────────────
      # Registry-first: ALL images (except registry:2) get a localhost:5000/
      # prefix tag so Swarm services can reference them from the local registry.
      echo ""
      echo "  Retagging core images for localhost:5000/..."
      CORE_RETAGGED=0
      if [ -f skopeo/core-images.txt ]; then
        while IFS= read -r line; do
          [[ "$line" =~ ^[[:space:]]*# ]] && continue
          [[ -z "${line// }" ]] && continue

          SOURCE_IMAGE=$(echo "$line" | cut -d'|' -f1 | xargs)
          TAG=$(echo "$line" | cut -d'|' -f2 | xargs)

          # Strip registry host prefix: docker.io/ or ghcr.io/
          REPO_NAME=$(echo "$SOURCE_IMAGE" | sed 's|^docker\.io/||; s|^ghcr\.io/||')

          # Determine the tag the image was loaded with in Step 3.
          # Docker Hub images load as repo:tag, GHCR images load as ghcr.io/repo:tag
          if echo "$SOURCE_IMAGE" | grep -q "^ghcr\.io/"; then
            LOADED_TAG="${SOURCE_IMAGE}:${TAG}"
          else
            LOADED_TAG="${REPO_NAME}:${TAG}"
          fi

          if $DOCKER_CMD tag "${LOADED_TAG}" "localhost:5000/${REPO_NAME}:${TAG}" 2>/dev/null; then
            echo "    ${LOADED_TAG} → localhost:5000/${REPO_NAME}:${TAG}"
            CORE_RETAGGED=$((CORE_RETAGGED + 1))
          else
            echo "    WARN: Could not retag ${LOADED_TAG} (image may not have loaded)"
          fi
        done < skopeo/core-images.txt
      fi
      echo "  Core images retagged: ${CORE_RETAGGED}"

      echo ""
      echo "Pre-load results: ${LOADED} core + ${CURATED_LOADED} curated loaded, ${CORE_RETAGGED} core retagged, ${FAILED} failed"
      $DOCKER_CMD images --format "  {{.Repository}}:{{.Tag}} ({{.Size}})"

      if [ "$FAILED" -gt 0 ]; then
        echo "WARNING: ${FAILED} images failed to load!"
        tail -20 /tmp/dockerd-preload.log
      fi

      # ── Step 4: Graceful shutdown ──────────────────────────────────
      # CRITICAL: Must use SIGTERM (not SIGKILL) to flush metadata to disk.
      # overlay2 metadata databases must be written out cleanly or the
      # Pi's dockerd will see a corrupted store on first boot.
      echo "Shutting down temporary dockerd..."
      kill -SIGTERM "$DOCKERD_PID"
      wait "$DOCKERD_PID" 2>/dev/null || true
      echo "  dockerd shut down cleanly"

      # ── Step 5: Cleanup ────────────────────────────────────────────
      # Remove the tarball cache from the image — no longer needed
      rm -rf /mnt/cubeos-image/var/cache/cubeos-images
      echo "  Removed tarball cache from image (images are in overlay2 now)"

      # Verify overlay2 data exists
      echo "  Docker storage size: $(du -sh /mnt/cubeos-image/var/lib/docker/ | cut -f1)"
      ls /mnt/cubeos-image/var/lib/docker/overlay2/ | wc -l | xargs -I{} echo "  overlay2 layers: {}"

      sync
      umount /mnt/cubeos-image
      losetup -d "$LOOPDEV" || true
      rmdir /mnt/cubeos-image 2>/dev/null || true

      echo "Docker pre-load complete: ${LOADED} core + ${CURATED_LOADED} curated images baked into ${IMAGE_NAME}.img"
      echo "Phase 1b: OK ($(date -u +%H:%M:%S))"
    - |
      set -e
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-arm64"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-arm64"; fi
      export IMAGE_NAME

      echo ""
      echo "============================================================"
      echo "  Phase 1c: Pre-populate local registry + ZIM content (${CUBEOS_VARIANT})"
      echo "  Started: $(date -u +%H:%M:%S)"
      echo "============================================================"

      # Skip if no images at all (core + curated)
      CORE_IMAGE_COUNT=$(find docker-images -maxdepth 1 -name '*.tar' 2>/dev/null | wc -l || echo 0)
      CURATED_COUNT=$(find curated-images -maxdepth 1 -name '*.tar' 2>/dev/null | wc -l || echo 0)
      if [ "$CORE_IMAGE_COUNT" -eq 0 ] && [ "$CURATED_COUNT" -eq 0 ]; then
        echo "No images found — skipping Phase 1c"
      else
        # ── Step 1: Mount the built image ──────────────────────────────
        LOOPDEV=$(losetup -fP --show ${IMAGE_NAME}.img)
        echo "Loop device: $LOOPDEV"
        sleep 2

        ROOT_PART="${LOOPDEV}p2"
        if [ ! -b "$ROOT_PART" ]; then
          echo "ERROR: Root partition ${ROOT_PART} not found"
          losetup -d "$LOOPDEV"
          exit 1
        fi

        mkdir -p /mnt/cubeos-image
        mount "$ROOT_PART" /mnt/cubeos-image
        echo "Mounted root partition at /mnt/cubeos-image"

        # ── Step 2: Ensure registry data directory exists ──────────────
        mkdir -p /mnt/cubeos-image/cubeos/data/registry

        # ── Step 2.5: Ensure registry:2 available on CI Docker ─────────
        # B56: Phase 1b loaded registry.tar into the mounted image's dockerd
        # (via custom socket). Phase 1c uses the CI host's Docker to run the
        # temp registry container — it needs registry:2 locally.
        if ! docker image inspect registry:2 &>/dev/null; then
            echo "  Loading registry:2 into CI Docker (B56 fix)..."
            docker load < docker-images/registry.tar 2>&1 || {
                echo "ERROR: Failed to load registry:2 — cannot populate local registry"
                sync
                umount /mnt/cubeos-image
                losetup -d "$LOOPDEV"
                exit 1
            }
        fi
        echo "  registry:2 available on CI Docker: OK"

        # ── Step 3: Start temp registry:2 against local storage ──────
        # B66v2: Previous approach used -v volume mount to map the mounted
        # image partition into the temp registry container. This FAILS in
        # Docker-in-Docker (GitLab CI): the -v path is interpreted from the
        # Docker HOST's perspective, not the CI container's mount namespace.
        # The CI container loop-mounts the image at /mnt/cubeos-image, but
        # the Docker host has nothing at that path — so the registry writes
        # to an empty dir on the host. Validation passes (queries the running
        # registry) but data never reaches the disk image.
        #
        # FIX: Start registry WITHOUT a host volume. Push images to it.
        # Then use `docker cp` to extract the registry data back into the
        # CI container's mount namespace (which sees the real partition).
        echo "Starting temporary registry:2 (no volume — will docker cp after push)..."
        docker rm -f cubeos-temp-registry 2>/dev/null || true

        docker run -d --name cubeos-temp-registry \
          -p 5099:5099 \
          -e REGISTRY_STORAGE_DELETE_ENABLED=true \
          -e REGISTRY_HTTP_ADDR=:5099 \
          registry:2

        # Discover reachable URL. In DinD, port-mapped container binds to
        # the Docker host — find container IP as fallback.
        REGISTRY_URL=""
        sleep 3

        # Try localhost first (works when not in DinD)
        if curl -sf "http://127.0.0.1:5099/v2/" &>/dev/null; then
          REGISTRY_URL="http://127.0.0.1:5099"
          echo "  Registry reachable at localhost:5099"
        else
          # DinD fallback: get container IP on bridge network
          CONTAINER_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' cubeos-temp-registry 2>/dev/null || true)
          if [ -n "$CONTAINER_IP" ] && curl -sf "http://${CONTAINER_IP}:5099/v2/" &>/dev/null; then
            REGISTRY_URL="http://${CONTAINER_IP}:5099"
            echo "  Registry reachable at container IP ${CONTAINER_IP}:5099"
          fi
        fi

        if [ -z "$REGISTRY_URL" ]; then
          echo "ERROR: Cannot reach temp registry at localhost:5099 or container IP"
          docker logs cubeos-temp-registry 2>&1 | tail -10
          docker rm -f cubeos-temp-registry 2>/dev/null || true
          umount /mnt/cubeos-image
          losetup -d "$LOOPDEV"
          exit 1
        fi

        echo "  Registry URL: ${REGISTRY_URL}"
        sleep 2

        # Wait for registry to be ready
        for i in $(seq 1 30); do
          if curl -sf "${REGISTRY_URL}/v2/" &>/dev/null; then
            echo "  Temp registry ready (${i}s)"
            break
          fi
          if [ "$i" -eq 30 ]; then
            echo "ERROR: Temp registry failed to start"
            docker logs cubeos-temp-registry 2>&1 | tail -10
            docker rm -f cubeos-temp-registry 2>/dev/null || true
            umount /mnt/cubeos-image
            losetup -d "$LOOPDEV"
            exit 1
          fi
          sleep 1
        done

        # ── Step 3.5: Push core images into registry ─────────────────
        # Registry-first: push ALL core images (except registry:2) so
        # services can pull from localhost:5000 on boot.
        CORE_PUSHED=0
        CORE_PUSH_FAILED=0
        # Extract host:port from REGISTRY_URL for docker:// transport
        REGISTRY_HOST=$(echo "$REGISTRY_URL" | sed 's|http://||')

        if [ -f skopeo/core-images.txt ]; then
          echo "Pushing core images into registry..."
          while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue

            SOURCE_IMAGE=$(echo "$line" | cut -d'|' -f1 | xargs)
            TAG=$(echo "$line" | cut -d'|' -f2 | xargs)
            FILENAME=$(echo "$line" | cut -d'|' -f3 | xargs)
            TARBALL="docker-images/${FILENAME}"

            # Strip registry host prefix for the repo name in our local registry
            REPO_NAME=$(echo "$SOURCE_IMAGE" | sed 's|^docker\.io/||; s|^ghcr\.io/||')

            if [ ! -f "$TARBALL" ]; then
              echo "  SKIP: ${TARBALL} not found"
              CORE_PUSH_FAILED=$((CORE_PUSH_FAILED + 1))
              continue
            fi

            echo "  Pushing ${REPO_NAME}:${TAG} → registry..."
            if skopeo copy \
              --override-arch arm64 \
              --override-os linux \
              --dest-tls-verify=false \
              "docker-archive:${TARBALL}" \
              "docker://${REGISTRY_HOST}/${REPO_NAME}:${TAG}" 2>&1; then
              echo "    OK"
              CORE_PUSHED=$((CORE_PUSHED + 1))
            else
              echo "    FAILED"
              CORE_PUSH_FAILED=$((CORE_PUSH_FAILED + 1))
            fi
          done < skopeo/core-images.txt
        fi

        echo ""
        echo "Core registry push results: ${CORE_PUSHED} pushed, ${CORE_PUSH_FAILED} failed"

        if [ "$CORE_PUSH_FAILED" -gt 0 ]; then
            echo "ERROR: ${CORE_PUSH_FAILED} core images failed to push to registry!"
            docker stop cubeos-temp-registry 2>/dev/null || true
            docker rm cubeos-temp-registry 2>/dev/null || true
            sync
            umount /mnt/cubeos-image
            losetup -d "$LOOPDEV"
            exit 1
        fi

        # ── Step 4: Push curated images into registry ──────────────────
        PUSHED=0
        PUSH_FAILED=0

        if [ "$CUBEOS_VARIANT" = "full" ]; then
          # Read manifest to get repo:tag mapping for each tarball
          while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue

            SOURCE_IMAGE=$(echo "$line" | cut -d'|' -f1 | xargs)
            TAG=$(echo "$line" | cut -d'|' -f2 | xargs)
            FILENAME=$(echo "$line" | cut -d'|' -f3 | xargs)
            TARBALL="curated-images/${FILENAME}"

            # Strip registry host prefix for the repo name in our local registry
            REPO_NAME=$(echo "$SOURCE_IMAGE" | sed 's|^docker\.io/||; s|^ghcr\.io/||')

            if [ ! -f "$TARBALL" ]; then
              echo "  SKIP: ${TARBALL} not found"
              PUSH_FAILED=$((PUSH_FAILED + 1))
              continue
            fi

            echo "  Pushing ${REPO_NAME}:${TAG} → registry..."
            if skopeo copy \
              --override-arch arm64 \
              --override-os linux \
              --dest-tls-verify=false \
              "docker-archive:${TARBALL}" \
              "docker://${REGISTRY_HOST}/${REPO_NAME}:${TAG}" 2>&1; then
              echo "    OK"
              PUSHED=$((PUSHED + 1))
            else
              echo "    FAILED"
              PUSH_FAILED=$((PUSH_FAILED + 1))
            fi
          done < skopeo/curated-apps.txt

          echo ""
          echo "Curated registry push results: ${PUSHED} pushed, ${PUSH_FAILED} failed"

          # B56: Fail build if any curated image failed to push — silent failures
          # previously caused kiwix to show 0/1 replicas on boot.
          if [ "$PUSH_FAILED" -gt 0 ]; then
              echo "ERROR: ${PUSH_FAILED} curated images failed to push to registry!"
              echo "Kiwix and other curated apps will not work on the built image."
              docker stop cubeos-temp-registry 2>/dev/null || true
              docker rm cubeos-temp-registry 2>/dev/null || true
              sync
              umount /mnt/cubeos-image
              losetup -d "$LOOPDEV"
              exit 1
          fi
        else
          echo "Lite variant: skipping curated image push"
        fi

        TOTAL_PUSHED=$((CORE_PUSHED + PUSHED))
        TOTAL_PUSH_FAILED=$((CORE_PUSH_FAILED + PUSH_FAILED))
        CORE_COUNT=$(grep -cv '^\s*#\|^\s*$' skopeo/core-images.txt)
        if [ "$CUBEOS_VARIANT" = "full" ]; then
          CURATED_COUNT=$(grep -cv '^\s*#\|^\s*$' skopeo/curated-apps.txt)
          EXPECTED=$((CORE_COUNT + CURATED_COUNT))
          echo "Total registry push: ${TOTAL_PUSHED} pushed, ${TOTAL_PUSH_FAILED} failed (${CORE_COUNT} core + ${CURATED_COUNT} curated = ${EXPECTED} expected)"
        else
          echo "Total registry push: ${TOTAL_PUSHED} pushed, ${TOTAL_PUSH_FAILED} failed (${CORE_COUNT} core expected)"
        fi

        # ── Step 5: Validate registry contents ─────────────────────────
        CORE_COUNT=$(grep -cv '^\s*#\|^\s*$' skopeo/core-images.txt)
        if [ "$CUBEOS_VARIANT" = "full" ]; then
          CURATED_COUNT=$(grep -cv '^\s*#\|^\s*$' skopeo/curated-apps.txt)
          EXPECTED=$((CORE_COUNT + CURATED_COUNT))
          echo ""
          echo "Validating registry contents (${EXPECTED} expected: ${CORE_COUNT} core + ${CURATED_COUNT} curated)..."
        else
          EXPECTED=${CORE_COUNT}
          echo ""
          echo "Validating registry contents (${EXPECTED} expected: ${CORE_COUNT} core)..."
        fi
        CATALOG=$(curl -sf "${REGISTRY_URL}/v2/_catalog" 2>/dev/null || echo '{"repositories":[]}')
        echo "  Catalog: ${CATALOG}"

        # Helper function: validate manifest has config digest
        validate_image() {
          local repo_name="$1" tag="$2"
          MANIFEST_RESP=$(curl -sf \
            -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
            "${REGISTRY_URL}/v2/${repo_name}/manifests/${tag}" 2>/dev/null || echo "")

          if [ -n "$MANIFEST_RESP" ]; then
            CONFIG_DIGEST=$(echo "$MANIFEST_RESP" | grep -o '"digest"[[:space:]]*:[[:space:]]*"sha256:[a-f0-9]*"' | head -1 | grep -o 'sha256:[a-f0-9]*' || echo "")

            if [ -n "$CONFIG_DIGEST" ]; then
              echo "  VALID: ${repo_name}:${tag} (config: ${CONFIG_DIGEST:0:19}...)"
              return 0
            else
              echo "  INVALID: ${repo_name}:${tag} (no config digest in manifest)"
              return 1
            fi
          else
            echo "  INVALID: ${repo_name}:${tag} (manifest not found)"
            return 1
          fi
        }

        VALID=0
        INVALID=0

        # Validate core images
        echo "  --- Core images ---"
        while IFS= read -r line; do
          [[ "$line" =~ ^[[:space:]]*# ]] && continue
          [[ -z "${line// }" ]] && continue

          SOURCE_IMAGE=$(echo "$line" | cut -d'|' -f1 | xargs)
          TAG=$(echo "$line" | cut -d'|' -f2 | xargs)
          REPO_NAME=$(echo "$SOURCE_IMAGE" | sed 's|^docker\.io/||; s|^ghcr\.io/||')

          if validate_image "$REPO_NAME" "$TAG"; then
            VALID=$((VALID + 1))
          else
            INVALID=$((INVALID + 1))
          fi
        done < skopeo/core-images.txt

        # Validate curated images (full only)
        if [ "$CUBEOS_VARIANT" = "full" ]; then
          echo "  --- Curated images ---"
          while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue

            SOURCE_IMAGE=$(echo "$line" | cut -d'|' -f1 | xargs)
            TAG=$(echo "$line" | cut -d'|' -f2 | xargs)
            REPO_NAME=$(echo "$SOURCE_IMAGE" | sed 's|^docker\.io/||; s|^ghcr\.io/||')

            if validate_image "$REPO_NAME" "$TAG"; then
              VALID=$((VALID + 1))
            else
              INVALID=$((INVALID + 1))
            fi
          done < skopeo/curated-apps.txt
        fi

        echo "  Validated: ${VALID}/${EXPECTED} images"
        if [ "$INVALID" -gt 0 ]; then
          echo "ERROR: ${INVALID} images failed validation!"
          docker stop cubeos-temp-registry 2>/dev/null || true
          docker rm cubeos-temp-registry 2>/dev/null || true
          sync
          umount /mnt/cubeos-image
          losetup -d "$LOOPDEV"
          exit 1
        fi

        # ── Step 6: Copy registry data to mounted image, then stop ────
        # B66v2: Registry data lives inside the container (no volume mount).
        # Use docker cp to extract it to the mounted image partition.
        echo "Copying registry data from container to image..."
        rm -rf /mnt/cubeos-image/cubeos/data/registry/*
        docker cp cubeos-temp-registry:/var/lib/registry/. /mnt/cubeos-image/cubeos/data/registry/

        # Verify data was actually copied
        COPY_SIZE=$(du -sh /mnt/cubeos-image/cubeos/data/registry/ 2>/dev/null | cut -f1)
        REPO_COUNT=$(find /mnt/cubeos-image/cubeos/data/registry/docker/registry/v2/repositories -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
        echo "  Copied: ${COPY_SIZE} (${REPO_COUNT} repositories on disk)"

        if [ "$REPO_COUNT" -eq 0 ]; then
          echo "ERROR: docker cp produced empty registry — no repositories on disk!"
          docker logs cubeos-temp-registry 2>&1 | tail -10
          docker rm -f cubeos-temp-registry 2>/dev/null || true
          sync
          umount /mnt/cubeos-image
          losetup -d "$LOOPDEV"
          exit 1
        fi

        echo "Stopping temp registry..."
        docker stop cubeos-temp-registry 2>/dev/null || true
        docker rm cubeos-temp-registry 2>/dev/null || true

        # Verify registry storage on disk
        REGISTRY_SIZE=$(du -sh /mnt/cubeos-image/cubeos/data/registry/ 2>/dev/null | cut -f1)
        echo "  Registry storage on disk: ${REGISTRY_SIZE}"

        # ── Step 7: Copy ZIM content into image ───────────────────────
        if [ -d "zim-content" ] && ls zim-content/*.zim &>/dev/null; then
          echo ""
          echo "Copying ZIM files into image..."
          mkdir -p /mnt/cubeos-image/cubeos/data/kiwix
          cp zim-content/*.zim /mnt/cubeos-image/cubeos/data/kiwix/
          # Kiwix container runs as UID 1001 — ensure it can read the files
          chown -R 1001:1001 /mnt/cubeos-image/cubeos/data/kiwix/
          ZIM_SIZE=$(du -sh /mnt/cubeos-image/cubeos/data/kiwix/ | cut -f1)
          echo "  ZIM content: ${ZIM_SIZE}"
        else
          echo ""
          echo "No ZIM files to copy (Kiwix will show empty library)"
          mkdir -p /mnt/cubeos-image/cubeos/data/kiwix
          chown -R 1001:1001 /mnt/cubeos-image/cubeos/data/kiwix/
        fi

        # ── Step 8: Unmount ────────────────────────────────────────────
        sync
        umount /mnt/cubeos-image
        losetup -d "$LOOPDEV"
        rmdir /mnt/cubeos-image 2>/dev/null || true

        echo ""
        echo "Phase 1c: OK — ${TOTAL_PUSHED} images in registry (${CORE_PUSHED} core + ${PUSHED} curated), ZIM content copied"
        echo "Phase 1c: OK ($(date -u +%H:%M:%S))"
      fi
    - |
      set -e
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-arm64"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-arm64"; fi
      export IMAGE_NAME

      echo ""
      echo "============================================================"
      echo "  Phase 1d: Post-Build File Validation (${CUBEOS_VARIANT})"
      echo "============================================================"
      # Loopback-mount the built image and verify critical files exist.
      # Catches missing boot scripts, broken configs, wrong version, etc.
      # BEFORE compression — cheapest place to catch errors.

      LOOPDEV=$(losetup -fP --show ${IMAGE_NAME}.img)
      echo "Loop device: $LOOPDEV"
      sleep 2

      ROOT_PART="${LOOPDEV}p2"
      BOOT_PART="${LOOPDEV}p1"
      MOUNT_DIR="/mnt/cubeos-validate"
      mkdir -p "$MOUNT_DIR"
      mount -o ro "$ROOT_PART" "$MOUNT_DIR"
      mount -o ro "$BOOT_PART" "$MOUNT_DIR/boot/firmware" 2>/dev/null || true

      VALIDATION_ERRORS=0
      val_check() {
        local label="$1" path="$2"
        if [ -e "${MOUNT_DIR}${path}" ]; then
          echo "  OK: ${label}"
        else
          echo "  FAIL: ${label} — ${path} missing"
          VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
        fi
      }

      echo ""
      echo "[1/6] Boot scripts..."
      val_check "cubeos-boot-lib.sh"       "/usr/local/bin/cubeos-boot-lib.sh"
      val_check "cubeos-first-boot.sh"     "/usr/local/bin/cubeos-first-boot.sh"
      val_check "cubeos-normal-boot.sh"    "/usr/local/bin/cubeos-normal-boot.sh"
      val_check "cubeos-boot-detect.sh"    "/usr/local/bin/cubeos-boot-detect.sh"
      val_check "cubeos-generate-secrets.sh" "/usr/local/bin/cubeos-generate-secrets.sh"
      val_check "cubeos-deploy-stacks.sh"  "/usr/local/bin/cubeos-deploy-stacks.sh"

      echo ""
      echo "[2/6] Systemd & services..."
      val_check "Docker daemon.json"       "/etc/docker/daemon.json"
      val_check "Netplan config"           "/etc/netplan/01-cubeos.yaml"
      val_check "hostapd config"           "/etc/hostapd/hostapd.conf"

      echo ""
      echo "[3/6] Security hardening (Phase 1.3)..."
      val_check "SSH 01-cubeos.conf"             "/etc/ssh/sshd_config.d/01-cubeos.conf"
      val_check "SSH 99-cubeos-hardening.conf"   "/etc/ssh/sshd_config.d/99-cubeos-hardening.conf"
      val_check "sysctl 99-cubeos.conf"          "/etc/sysctl.d/99-cubeos.conf"
      val_check "sysctl 99-cubeos-security.conf" "/etc/sysctl.d/99-cubeos-security.conf"
      val_check "journald cubeos.conf"           "/etc/systemd/journald.conf.d/cubeos.conf"
      val_check "watchdog cubeos-watchdog.conf"  "/etc/systemd/system.conf.d/cubeos-watchdog.conf"
      val_check "fail2ban cubeos-sshd.conf"      "/etc/fail2ban/jail.d/cubeos-sshd.conf"

      echo ""
      echo "[4/6] CubeOS directories & config..."
      val_check "/cubeos/config/defaults.env"    "/cubeos/config/defaults.env"
      val_check "/cubeos/data/"                  "/cubeos/data/"
      val_check "/cubeos/coreapps/"              "/cubeos/coreapps/"
      val_check "/cubeos/docs/"                  "/cubeos/docs/"

      echo ""
      echo "[5/6] Compose files..."
      val_check "pihole compose"      "/cubeos/coreapps/pihole/appconfig/docker-compose.yml"
      val_check "npm compose"         "/cubeos/coreapps/npm/appconfig/docker-compose.yml"
      val_check "cubeos-api compose"  "/cubeos/coreapps/cubeos-api/appconfig/docker-compose.yml"
      val_check "cubeos-hal compose"  "/cubeos/coreapps/cubeos-hal/appconfig/docker-compose.yml"
      val_check "cubeos-dashboard compose" "/cubeos/coreapps/cubeos-dashboard/appconfig/docker-compose.yml"

      echo ""
      echo "[6/6] Version & metadata..."
      val_check "/etc/cubeos-version"  "/etc/cubeos-version"
      if [ -f "${MOUNT_DIR}/etc/cubeos-version" ]; then
        BAKED_VERSION=$(cat "${MOUNT_DIR}/etc/cubeos-version")
        if [ "$BAKED_VERSION" = "$CUBEOS_VERSION" ]; then
          echo "  OK: Version matches ($BAKED_VERSION)"
        else
          echo "  FAIL: Version mismatch — baked=$BAKED_VERSION expected=$CUBEOS_VERSION"
          VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
        fi
      fi

      # Spot-check security content (not just file existence)
      echo ""
      echo "[SPOT] Content verification..."
      if grep -q "PermitRootLogin no" "${MOUNT_DIR}/etc/ssh/sshd_config.d/99-cubeos-hardening.conf" 2>/dev/null; then
        echo "  OK: SSH PermitRootLogin=no"
      else
        echo "  FAIL: SSH PermitRootLogin not set to no"
        VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
      fi
      if grep -q "Storage=volatile" "${MOUNT_DIR}/etc/systemd/journald.conf.d/cubeos.conf" 2>/dev/null; then
        echo "  OK: journald Storage=volatile"
      else
        echo "  FAIL: journald not set to volatile"
        VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
      fi
      if grep -q "RuntimeWatchdogSec=10s" "${MOUNT_DIR}/etc/systemd/system.conf.d/cubeos-watchdog.conf" 2>/dev/null; then
        echo "  OK: watchdog RuntimeWatchdogSec=10s"
      else
        echo "  FAIL: watchdog not configured"
        VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
      fi

      # Cleanup
      umount "$MOUNT_DIR/boot/firmware" 2>/dev/null || true
      umount "$MOUNT_DIR"
      losetup -d "$LOOPDEV"
      rmdir "$MOUNT_DIR" 2>/dev/null || true

      echo ""
      if [ "$VALIDATION_ERRORS" -gt 0 ]; then
        echo "============================================================"
        echo "  VALIDATION FAILED: $VALIDATION_ERRORS errors detected"
        echo "  Image will NOT be compressed. Fix the build and retry."
        echo "============================================================"
        exit 1
      else
        echo "============================================================"
        echo "  Phase 1d: PASSED — All files verified"
        echo "============================================================"
      fi
    - |
      set -e
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-arm64"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-arm64"; fi
      export IMAGE_NAME

      echo ""
      echo "============================================================"
      echo "  Phase 2: Shrink + Compress (${CUBEOS_VARIANT})"
      echo "============================================================"

      # PiShrink
      echo "[1/5] Running PiShrink..."
      wget -q -O pishrink.sh https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh || echo "WARN PiShrink download failed, skipping"
      if [ -f pishrink.sh ]; then
        chmod +x pishrink.sh
        timeout 300 bash pishrink.sh -s ${IMAGE_NAME}.img || echo "WARN: PiShrink failed or timed out (non-fatal — zerofree runs next)"
      fi

      # Zerofree
      echo "[2/5] Running zerofree..."
      LOOPDEV=$(losetup -fP --show ${IMAGE_NAME}.img)
      echo "Loop device: $LOOPDEV"
      sleep 2
      ROOT_PART="${LOOPDEV}p2"
      if [ -b "$ROOT_PART" ]; then
        e2fsck -fy "$ROOT_PART" || true
        zerofree -v "$ROOT_PART" || echo "WARN zerofree failed (non-fatal)"
      fi
      losetup -d "$LOOPDEV"

      # XZ compress
      echo "[3/5] Compressing with xz -6 (multi-threaded)..."
      ls -lh ${IMAGE_NAME}.img
      xz -6 -T0 -v ${IMAGE_NAME}.img

      # Checksums (standard + Pi Imager)
      echo "[4/5] Calculating checksums..."
      sha256sum ${IMAGE_NAME}.img.xz > ${IMAGE_NAME}.img.xz.sha256
      md5sum ${IMAGE_NAME}.img.xz > ${IMAGE_NAME}.img.xz.md5
      # Pi Imager needs both compressed and extracted checksums
      # calculate-checksums.sh requires uncompressed .img — decompress temporarily
      echo "[5/5] Generating Pi Imager checksums..."
      xz -dk ${IMAGE_NAME}.img.xz  # decompress, keep .xz
      chmod +x scripts/calculate-checksums.sh
      bash scripts/calculate-checksums.sh ${IMAGE_NAME}
      rm -f ${IMAGE_NAME}.img  # remove uncompressed copy
    - |
      set -e
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-arm64"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-arm64"; fi
      export IMAGE_NAME

      echo ""
      echo "============================================================"
      echo "  Phase 3: Upload to GitLab Package Registry (${CUBEOS_VARIANT})"
      echo "============================================================"

      echo "Uploading ${IMAGE_NAME}..."
      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           --upload-file ${IMAGE_NAME}.img.xz \
           --connect-timeout 30 \
           --max-time 1800 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz"
      echo "  Image uploaded."

      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           --upload-file ${IMAGE_NAME}.img.xz.sha256 \
           --connect-timeout 30 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz.sha256"
      echo "  SHA256 uploaded."

      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           --upload-file ${IMAGE_NAME}.img.xz.md5 \
           --connect-timeout 30 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz.md5"
      echo "  MD5 uploaded."

      echo ""
      echo "============================================================"
      echo "  CubeOS Release Image — Build Complete (${CUBEOS_VARIANT})"
      echo "============================================================"
      echo "  Version   ${CUBEOS_VERSION}"
      echo "  Variant   ${CUBEOS_VARIANT}"
      echo "  File      ${IMAGE_NAME}.img.xz"
      echo "  Size      $(du -h ${IMAGE_NAME}.img.xz | cut -f1)"
      echo "  SHA256    $(cut -d' ' -f1 ${IMAGE_NAME}.img.xz.sha256)"
      echo "  Base      cubeos-base/${BASE_VERSION}"
      echo "============================================================"
  artifacts:
    paths:
      - "cubeos-*.img.xz.sha256"
      - "cubeos-*.img.xz.md5"
      - "cubeos-*.img.sha256"
    expire_in: 30 days
  after_script:
    - docker rm -f cubeos-temp-registry 2>/dev/null || true
    - umount /mnt/cubeos-image 2>/dev/null || true
    - losetup -D 2>/dev/null || true
  timeout: 60m

# =============================================================================
# Create GitLab Release (tag push only — uses pre-built image from Package Registry)
# =============================================================================
create-gitlab-release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v/'
  variables:
    FULL_IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-arm64"
    LITE_IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-lite-arm64"
  script:
    - |
      echo "Creating GitLab release for ${CI_COMMIT_TAG}..."

      # Download checksums from Package Registry (uploaded during build-image)
      echo "Fetching checksums from Package Registry..."
      apk add --no-cache curl 2>/dev/null || true

      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           -o ${FULL_IMAGE_NAME}.img.xz.sha256 \
           --connect-timeout 30 \
           --retry 3 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${FULL_IMAGE_NAME}.img.xz.sha256"

      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           -o ${LITE_IMAGE_NAME}.img.xz.sha256 \
           --connect-timeout 30 \
           --retry 3 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${LITE_IMAGE_NAME}.img.xz.sha256"

      FULL_CHECKSUM=$(cut -d' ' -f1 ${FULL_IMAGE_NAME}.img.xz.sha256)
      LITE_CHECKSUM=$(cut -d' ' -f1 ${LITE_IMAGE_NAME}.img.xz.sha256)
      echo "Full SHA256: ${FULL_CHECKSUM}"
      echo "Lite SHA256: ${LITE_CHECKSUM}"

      if [ -z "$FULL_CHECKSUM" ] || [ -z "$LITE_CHECKSUM" ]; then
        echo "ERROR: Image(s) not found in Package Registry."
        echo "Did you push to main first? build-image must succeed before tagging."
        exit 1
      fi
  release:
    tag_name: "${CI_COMMIT_TAG}"
    name: "CubeOS ${CI_COMMIT_TAG}"
    description: |
      ## CubeOS ${CI_COMMIT_TAG}

      Flashable ARM64 images for Raspberry Pi 4/5 (Ubuntu 24.04.3 based).

      ### Variants
      - **Full**: All services + offline content (4GB+ RAM recommended)
      - **Lite**: Core platform only, install apps from App Store (2GB+ RAM)

      ### Quick Start
      1. Flash the .img.xz to SD card using Raspberry Pi Imager
      2. Boot the Pi
      3. Connect to WiFi AP (check console output for SSID and password)
      4. Open http://cubeos.cube in your browser
      5. Complete the setup wizard

      ### Default Credentials
      - Dashboard: admin / cubeos
      - SSH: cubeos / cubeos (or key-based if configured in Imager)
    assets:
      links:
        - name: "cubeos-${CUBEOS_VERSION}-arm64.img.xz (Full)"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/cubeos-${CUBEOS_VERSION}-arm64.img.xz"
        - name: "cubeos-${CUBEOS_VERSION}-lite-arm64.img.xz (Lite)"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/cubeos-${CUBEOS_VERSION}-lite-arm64.img.xz"
        - name: "Full SHA256 Checksum"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/cubeos-${CUBEOS_VERSION}-arm64.img.xz.sha256"
        - name: "Lite SHA256 Checksum"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/cubeos-${CUBEOS_VERSION}-lite-arm64.img.xz.sha256"

# =============================================================================
# Create GitHub Release (mirror — tag push only, with binary upload)
# =============================================================================
# Uploads both Full and Lite images + Pi Imager manifest as release assets.
# =============================================================================
create-github-release:
  stage: release
  image: alpine:latest
  variables:
    FULL_IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-arm64"
    LITE_IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-lite-arm64"
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v/'
  script:
    - |
      set -e
      apk add --no-cache curl jq bash

      if [ -z "${GHCR_TOKEN:-}" ]; then
        echo "WARN: GHCR_TOKEN not set — skipping GitHub release."
        exit 0
      fi

      # --- Step 1: Download both images + checksums from GitLab Package Registry ---
      echo "============================================================"
      echo "  Step 1: Download from GitLab Package Registry"
      echo "============================================================"

      # Helper: download a file from Package Registry
      download_pkg() {
        local filename="$1"
        echo "Downloading ${filename}..."
        curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
             -o "${filename}" \
             --connect-timeout 30 \
             --max-time 3600 \
             --retry 3 \
             --retry-delay 60 \
             "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${filename}"
      }

      # Download checksums
      download_pkg "${FULL_IMAGE_NAME}.img.xz.sha256"
      download_pkg "${LITE_IMAGE_NAME}.img.xz.sha256"

      FULL_CHECKSUM=$(cut -d' ' -f1 "${FULL_IMAGE_NAME}.img.xz.sha256")
      LITE_CHECKSUM=$(cut -d' ' -f1 "${LITE_IMAGE_NAME}.img.xz.sha256")
      echo "Full SHA256: ${FULL_CHECKSUM}"
      echo "Lite SHA256: ${LITE_CHECKSUM}"

      if [ -z "$FULL_CHECKSUM" ] || [ -z "$LITE_CHECKSUM" ]; then
        echo "ERROR: Image(s) not found in Package Registry."
        exit 1
      fi

      # Download images
      download_pkg "${FULL_IMAGE_NAME}.img.xz"
      download_pkg "${LITE_IMAGE_NAME}.img.xz"

      echo "Full: $(du -h ${FULL_IMAGE_NAME}.img.xz | cut -f1)"
      echo "Lite: $(du -h ${LITE_IMAGE_NAME}.img.xz | cut -f1)"

      # Verify checksums
      echo "Verifying checksums..."
      echo "${FULL_CHECKSUM}  ${FULL_IMAGE_NAME}.img.xz" | sha256sum -c -
      echo "${LITE_CHECKSUM}  ${LITE_IMAGE_NAME}.img.xz" | sha256sum -c -

      # --- Step 1b: Generate Pi Imager manifest ---
      echo "============================================================"
      echo "  Step 1b: Generate Pi Imager manifest"
      echo "============================================================"
      # Decompress both images temporarily to calculate Pi Imager checksums
      xz -dk ${FULL_IMAGE_NAME}.img.xz
      xz -dk ${LITE_IMAGE_NAME}.img.xz
      chmod +x scripts/calculate-checksums.sh scripts/update-manifest.sh
      bash scripts/update-manifest.sh "${CUBEOS_VERSION}"
      rm -f ${FULL_IMAGE_NAME}.img ${LITE_IMAGE_NAME}.img
      echo "Manifest generated:"
      cat imager/rpi-imager.json

      # --- Step 2: Create GitHub Release ---
      echo "============================================================"
      echo "  Step 2: Create GitHub Release"
      echo "============================================================"

      RELEASE_BODY="## CubeOS ${CI_COMMIT_TAG}

      Flashable ARM64 images for Raspberry Pi 4/5 (Ubuntu 24.04.3 based).

      ### Variants
      | Variant | Size | Description |
      |---------|------|-------------|
      | **Full** | $(du -h ${FULL_IMAGE_NAME}.img.xz | cut -f1) | All services + offline content (4GB+ RAM) |
      | **Lite** | $(du -h ${LITE_IMAGE_NAME}.img.xz | cut -f1) | Core platform only (2GB+ RAM) |

      ### Pi Imager
      Add CubeOS to Raspberry Pi Imager with this custom repository URL:
      \`\`\`
      https://github.com/${GITHUB_REPO}/releases/download/${CI_COMMIT_TAG}/rpi-imager.json
      \`\`\`

      ### Quick Start
      1. Flash the .img.xz to SD card using Raspberry Pi Imager
      2. Boot the Pi — connect to the CubeOS WiFi AP
      3. Open http://cubeos.cube and complete setup wizard

      ### Default Credentials
      - **SSH:** cubeos / cubeos
      - **Dashboard:** admin / cubeos"

      echo "Creating GitHub release for ${CI_COMMIT_TAG} on ${GITHUB_REPO}..."
      RESPONSE=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: token ${GHCR_TOKEN}" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/${GITHUB_REPO}/releases" \
        -d "$(jq -n \
          --arg tag "${CI_COMMIT_TAG}" \
          --arg name "CubeOS ${CI_COMMIT_TAG}" \
          --arg body "${RELEASE_BODY}" \
          '{tag_name: $tag, name: $name, body: $body, draft: false, prerelease: true}'
        )")

      HTTP_CODE=$(echo "$RESPONSE" | tail -1)
      RESP_BODY=$(echo "$RESPONSE" | sed '$d')
      echo "GitHub API: HTTP ${HTTP_CODE}"

      if [ "$HTTP_CODE" = "201" ]; then
        RELEASE_ID=$(echo "$RESP_BODY" | jq -r '.id')
        UPLOAD_URL=$(echo "$RESP_BODY" | jq -r '.upload_url' | sed 's/{?name,label}//')
        echo "  Release created (ID: ${RELEASE_ID})"
      elif [ "$HTTP_CODE" = "422" ]; then
        echo "  Release already exists — fetching existing release..."
        EXISTING=$(curl -s \
          -H "Authorization: token ${GHCR_TOKEN}" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${GITHUB_REPO}/releases/tags/${CI_COMMIT_TAG}")
        RELEASE_ID=$(echo "$EXISTING" | jq -r '.id')
        UPLOAD_URL=$(echo "$EXISTING" | jq -r '.upload_url' | sed 's/{?name,label}//')

        curl -s -X PATCH \
          -H "Authorization: token ${GHCR_TOKEN}" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${GITHUB_REPO}/releases/${RELEASE_ID}" \
          -d "$(jq -n \
            --arg body "${RELEASE_BODY}" \
            '{body: $body}'
          )" > /dev/null

        # Delete existing assets (re-upload fresh)
        echo "  Deleting old assets..."
        ASSETS=$(curl -s \
          -H "Authorization: token ${GHCR_TOKEN}" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${GITHUB_REPO}/releases/${RELEASE_ID}/assets")
        echo "$ASSETS" | jq -r '.[].id' | while read ASSET_ID; do
          curl -s -X DELETE \
            -H "Authorization: token ${GHCR_TOKEN}" \
            "https://api.github.com/repos/${GITHUB_REPO}/releases/assets/${ASSET_ID}" || true
        done
        echo "  Updated existing release (ID: ${RELEASE_ID})"
      else
        echo "  ERROR: Unexpected response."
        echo "$RESP_BODY" | jq . 2>/dev/null || echo "$RESP_BODY"
        exit 1
      fi

      # --- Step 3: Upload all assets ---
      echo "============================================================"
      echo "  Step 3: Upload assets to GitHub Release"
      echo "============================================================"

      upload_asset() {
        local filename="$1" content_type="$2"
        echo "Uploading ${filename} ($(du -h ${filename} | cut -f1))..."
        local RESP CODE
        RESP=$(curl -s -w "\n%{http_code}" \
          --max-time 3600 \
          -X POST \
          -H "Authorization: token ${GHCR_TOKEN}" \
          -H "Content-Type: ${content_type}" \
          "${UPLOAD_URL}?name=${filename}" \
          --data-binary "@${filename}")
        CODE=$(echo "$RESP" | tail -1)
        if [ "$CODE" = "201" ]; then
          echo "  OK: ${filename}"
        else
          echo "  WARN: ${filename} upload failed (HTTP ${CODE})"
        fi
      }

      # Full image + checksum
      upload_asset "${FULL_IMAGE_NAME}.img.xz" "application/x-xz"
      upload_asset "${FULL_IMAGE_NAME}.img.xz.sha256" "text/plain"

      # Lite image + checksum
      upload_asset "${LITE_IMAGE_NAME}.img.xz" "application/x-xz"
      upload_asset "${LITE_IMAGE_NAME}.img.xz.sha256" "text/plain"

      # Pi Imager manifest
      upload_asset "imager/rpi-imager.json" "application/json"

      echo "============================================================"
      echo "  GitHub Release complete!"
      echo "  https://github.com/${GITHUB_REPO}/releases/tag/${CI_COMMIT_TAG}"
      echo "  Pi Imager URL: https://github.com/${GITHUB_REPO}/releases/download/${CI_COMMIT_TAG}/rpi-imager.json"
      echo "============================================================"
  allow_failure: true
  timeout: 120m
