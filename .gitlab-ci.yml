# =============================================================================
# CubeOS Release Image Pipeline
# =============================================================================
# Builds flashable ARM64 images (Full + Lite) from the golden base image.
#
# WORKFLOW (build once, release later):
#   1. Push script changes → only lint + sync-installer (if install.sh changed)
#   2. Push "chore: bump version to vX.Y.Z" → build-image + full release chain
#   3. Tag (git tag v0.1.0-alpha.10 && git push --tags)
#      → release jobs run (~2 min), create GitLab + GitHub releases
#      → NO rebuild — release jobs download the already-built images
#
# VARIANTS:
#   Full: All services + offline content (docsindex, dozzle, kiwix, curated apps)
#   Lite: Core services only (pihole, npm, hal, api, dashboard, registry, terminal)
#
# SINGLE JOB BUILD: Everything runs in one container to avoid transferring
# 1.5GB+ of Docker image tarballs as CI artifacts between stages.
#
# PREREQUISITES:
#   1. Golden base image in Package Registry (cubeos-base/1.1.0)
#   2. CI variables: GHCR_USER, GHCR_TOKEN (for private GHCR images)
#   3. CI variable: GHCR_TOKEN (used for both GHCR pushes and GitHub API releases)
#   4. Token access: releases project allowed to access coreapps project
#
# TIME: ~20 minutes per variant (build) + ~5 minutes (validate) + ~2 minutes (release on tag)
# =============================================================================

# Pipeline creation rules — skip pipeline entirely when there's no work to do.
# Without this, non-matching pushes create empty pipelines that show as "failed".
workflow:
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v/'                                  # Tag push → release jobs
    - if: '$CI_COMMIT_MESSAGE =~ /^chore: bump version to /'        # Version bump → full build chain
    - if: '$CI_PIPELINE_SOURCE == "web"'                             # Manual web trigger
    - if: '$CI_PIPELINE_SOURCE == "api"'                             # API trigger
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - curl/install.sh                                            # install.sh change → sync-installer
    - when: never                                                    # Everything else → no pipeline

stages:
  - build
  - validate    # Post-build filesystem inspection (QEMU mount, no boot)
  - boot-test   # QEMU boot verification (x86_64 only)
  - upload      # Push images to DMZ + update GitHub/website (every main push)
  - release
  - deploy      # Upload to releases server + update channel metadata
  - publish     # Sync artifacts to other repos (install.sh → website)
  - tag         # Tag all repos on release (mirrors to GitHub automatically)

variables:
  # CubeOS release version baked into images and used for Package Registry paths
  CUBEOS_VERSION: "0.2.0-beta.05"
  # Golden base image version (monthly rebuild on GPU VM)
  BASE_VERSION: "3.0.0"
  # Golden base image filename in Package Registry
  BASE_IMAGE_NAME: "cubeos-base-ubuntu24.04.3-arm64"
  # GitHub mirror repo for release asset uploads
  GITHUB_REPO: "cubeos-app/releases"

# =============================================================================
# Build Release Image (Full + Lite variants via parallel matrix)
# =============================================================================
build-image:
  stage: build
  image:
    name: mkaczanowski/packer-builder-arm:latest
    entrypoint: [""]
  parallel:
    matrix:
      # Raspberry Pi — builds with packer-builder-arm (chroot)
      - CUBEOS_PLATFORM: "raspberrypi"
        CUBEOS_VARIANT: "full"
        CUBEOS_ARCH: "arm64"
        IMAGE_SIZE: "12G"
        PACKER_TEMPLATE: "platforms/raspberrypi/packer.pkr.hcl"
      - CUBEOS_PLATFORM: "raspberrypi"
        CUBEOS_VARIANT: "lite"
        CUBEOS_ARCH: "arm64"
        IMAGE_SIZE: "10G"
        PACKER_TEMPLATE: "platforms/raspberrypi/packer.pkr.hcl"
      # BananaPi — DISABLED (placeholder, uncomment when base image + hardware verified)
      # - CUBEOS_PLATFORM: "bananapi"
      #   CUBEOS_VARIANT: "full"
      #   CUBEOS_ARCH: "arm64"
      #   IMAGE_SIZE: "12G"
      #   PACKER_TEMPLATE: "platforms/bananapi/packer.pkr.hcl"
      # - CUBEOS_PLATFORM: "bananapi"
      #   CUBEOS_VARIANT: "lite"
      #   CUBEOS_ARCH: "arm64"
      #   IMAGE_SIZE: "10G"
      #   PACKER_TEMPLATE: "platforms/bananapi/packer.pkr.hcl"
      # BananaPi M4 Zero — DISABLED (placeholder, uncomment when base image + hardware verified)
      # - CUBEOS_PLATFORM: "bananapim4zero"
      #   CUBEOS_VARIANT: "full"
      #   CUBEOS_ARCH: "arm64"
      #   IMAGE_SIZE: "12G"
      #   PACKER_TEMPLATE: "platforms/bananapim4zero/packer.pkr.hcl"
      # - CUBEOS_PLATFORM: "bananapim4zero"
      #   CUBEOS_VARIANT: "lite"
      #   CUBEOS_ARCH: "arm64"
      #   IMAGE_SIZE: "10G"
      #   PACKER_TEMPLATE: "platforms/bananapim4zero/packer.pkr.hcl"
      # Pine64 — DISABLED (placeholder, uncomment when base image + hardware verified)
      # - CUBEOS_PLATFORM: "pine64"
      #   CUBEOS_VARIANT: "full"
      #   CUBEOS_ARCH: "arm64"
      #   IMAGE_SIZE: "12G"
      #   PACKER_TEMPLATE: "platforms/pine64/packer.pkr.hcl"
      # - CUBEOS_PLATFORM: "pine64"
      #   CUBEOS_VARIANT: "lite"
      #   CUBEOS_ARCH: "arm64"
      #   IMAGE_SIZE: "10G"
      #   PACKER_TEMPLATE: "platforms/pine64/packer.pkr.hcl"
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_COMMIT_MESSAGE =~ /^chore: bump version to /'
    - if: '$CI_PIPELINE_SOURCE == "web"'
    - when: never
  script:
    - |
      set -e

      # ── Compute platform + variant-specific IMAGE_NAME ─────────────
      # Pi keeps backward-compatible names: cubeos-X.Y.Z-arm64
      # Other platforms: cubeos-X.Y.Z-{platform}-{arch}
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then
        PLATFORM_SUFFIX="arm64"
      elif [ "$CUBEOS_PLATFORM" = "x86_64" ]; then
        PLATFORM_SUFFIX="amd64"
      else
        PLATFORM_SUFFIX="${CUBEOS_PLATFORM}-arm64"
      fi
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${PLATFORM_SUFFIX}"
      else
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${PLATFORM_SUFFIX}"
      fi
      export IMAGE_NAME PLATFORM_SUFFIX
      DOCKER_ARCH="${CUBEOS_ARCH:-arm64}"
      export DOCKER_ARCH
      echo "PLATFORM=${CUBEOS_PLATFORM} VARIANT=${CUBEOS_VARIANT} ARCH=${DOCKER_ARCH} IMAGE_NAME=${IMAGE_NAME} IMAGE_SIZE=${IMAGE_SIZE}"

      echo "============================================================"
      echo "  CubeOS Release Pipeline — Phase 0: Setup (${CUBEOS_VARIANT})"
      echo "============================================================"

      # Validate CI variables
      if [ -z "${GHCR_USER:-}" ] || [ -z "${GHCR_TOKEN:-}" ]; then
        echo "ERROR: GHCR_USER and GHCR_TOKEN CI variables are required."
        echo "Set them in: Settings > CI/CD > Variables"
        exit 1
      fi
      echo "GHCR auth: ${GHCR_USER}"

      # QEMU binfmt
      mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc || true
      if [ ! -f /proc/sys/fs/binfmt_misc/qemu-aarch64 ]; then
        echo "ERROR: QEMU aarch64 binfmt not registered on host!"
        exit 1
      fi
      echo "QEMU aarch64 binfmt: OK"

      # Install tools
      echo "Installing tools..."
      # Refresh APT keys if stale (packer-builder-arm image may have outdated Ubuntu Jammy keyring)
      apt-get update -q 2>&1 | tail -3 || {
        echo "WARN: apt-get update failed — refreshing GPG keys..."
        apt-key adv --refresh-keys --keyserver keyserver.ubuntu.com 2>&1 | tail -3 || true
        rm -rf /var/lib/apt/lists/*
        apt-get update -q 2>&1 | tail -3
      }
      apt-get install -y -q docker.io skopeo xz-utils zerofree e2fsprogs parted wget kpartx util-linux curl jq git zstd 2>&1 | tail -5
      echo "  skopeo $(skopeo --version 2>/dev/null | head -1)"
    - |
      set -e
      # Re-export IMAGE_NAME (each script block is a new shell)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then PLATFORM_SUFFIX="arm64"; elif [ "$CUBEOS_PLATFORM" = "x86_64" ]; then PLATFORM_SUFFIX="amd64"; else PLATFORM_SUFFIX="${CUBEOS_PLATFORM}-arm64"; fi
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${PLATFORM_SUFFIX}"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${PLATFORM_SUFFIX}"; fi
      export IMAGE_NAME PLATFORM_SUFFIX
      DOCKER_ARCH="${CUBEOS_ARCH:-arm64}"; export DOCKER_ARCH

      echo ""
      echo "============================================================"
      echo "  Phase 0a: Clone coreapps repo (${CUBEOS_VARIANT})"
      echo "============================================================"

      git clone --depth 1 \
        "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/products/cubeos/coreapps.git" \
        /tmp/coreapps-src

      # Lite variant: only core services
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        SERVICES="pihole npm cubeos-api cubeos-hal cubeos-dashboard registry terminal"
      else
        SERVICES="pihole npm cubeos-api cubeos-hal cubeos-dashboard cubeos-docsindex registry dozzle terminal kiwix filebrowser chromadb"
      fi

      mkdir -p coreapps-bundle
      for svc in $SERVICES; do
        if [ -d "/tmp/coreapps-src/${svc}/appconfig" ]; then
          mkdir -p "coreapps-bundle/${svc}"
          cp -r "/tmp/coreapps-src/${svc}/appconfig" "coreapps-bundle/${svc}/"
          echo "  + ${svc}/appconfig"
        else
          echo "  - ${svc} (not found or no appconfig)"
        fi
      done

      if [ -d "/tmp/coreapps-src/scripts" ]; then
        cp -r /tmp/coreapps-src/scripts coreapps-bundle/
        chmod +x coreapps-bundle/scripts/*.sh 2>/dev/null || true
        echo "  + scripts/"
      fi

      echo ""
      echo "Coreapps bundle:"
      find coreapps-bundle -type f | sort
      rm -rf /tmp/coreapps-src
      echo "Coreapps bundle: OK"

      # Clone docs repo for offline filesystem mode (T05)
      # B05: Try GitHub first, then GitLab, then mark as unavailable (04-cubeos.sh has fallback)
      echo ""
      echo "  Cloning docs repo for offline access..."
      DOCS_CLONED=false
      git clone --depth=1 https://github.com/cubeos-app/docs.git /tmp/cubeos-docs-src 2>&1 | tail -3 && \
        DOCS_CLONED=true && echo "  + docs repo cloned from GitHub" || \
        echo "  - GitHub docs clone failed, trying GitLab..."
      if [ "$DOCS_CLONED" = "false" ]; then
        git clone --depth=1 \
          "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/products/cubeos/docs.git" \
          /tmp/cubeos-docs-src 2>&1 | tail -3 && \
          DOCS_CLONED=true && echo "  + docs repo cloned from GitLab" || \
          echo "  - GitLab docs clone also failed (non-fatal, 04-cubeos.sh has placeholder fallback)"
      fi
      if [ -d /tmp/cubeos-docs-src ]; then
        mkdir -p coreapps-bundle/docs
        # Copy .md files only (exclude .git and other artifacts)
        find /tmp/cubeos-docs-src -maxdepth 2 -name '*.md' -exec cp {} coreapps-bundle/docs/ \; 2>/dev/null || true
        rm -rf /tmp/cubeos-docs-src
        DOCS_COUNT=$(find coreapps-bundle/docs -name '*.md' 2>/dev/null | wc -l)
        echo "  + ${DOCS_COUNT} docs bundled into coreapps-bundle/docs/"
      fi
    - |
      set -e
      # Re-export IMAGE_NAME (each script block is a new shell)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then PLATFORM_SUFFIX="arm64"; elif [ "$CUBEOS_PLATFORM" = "x86_64" ]; then PLATFORM_SUFFIX="amd64"; else PLATFORM_SUFFIX="${CUBEOS_PLATFORM}-arm64"; fi
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${PLATFORM_SUFFIX}"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${PLATFORM_SUFFIX}"; fi
      export IMAGE_NAME PLATFORM_SUFFIX
      DOCKER_ARCH="${CUBEOS_ARCH:-arm64}"; export DOCKER_ARCH

      echo ""
      echo "============================================================"
      echo "  Phase 0b: Download ARM64 Docker images (${CUBEOS_VARIANT})"
      echo "============================================================"

      mkdir -p docker-images
      IMG_COUNT=0

      # ── Core images (both variants) ──────────────────────────────────
      echo "[core] Pi-hole..."
      skopeo copy --override-arch $DOCKER_ARCH --override-os linux --retry-times 3 \
        docker://docker.io/pihole/pihole:latest \
        docker-archive:docker-images/pihole.tar:pihole/pihole:latest
      IMG_COUNT=$((IMG_COUNT + 1))
      sleep 2

      echo "[core] Nginx Proxy Manager..."
      skopeo copy --override-arch $DOCKER_ARCH --override-os linux --retry-times 3 \
        docker://docker.io/jc21/nginx-proxy-manager:latest \
        docker-archive:docker-images/npm.tar:jc21/nginx-proxy-manager:latest
      IMG_COUNT=$((IMG_COUNT + 1))
      sleep 2

      echo "[core] CubeOS API..."
      skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" \
        --override-arch $DOCKER_ARCH --override-os linux --retry-times 3 \
        docker://ghcr.io/cubeos-app/api:latest \
        docker-archive:docker-images/cubeos-api.tar:ghcr.io/cubeos-app/api:latest
      IMG_COUNT=$((IMG_COUNT + 1))
      sleep 2

      echo "[core] CubeOS HAL..."
      skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" \
        --override-arch $DOCKER_ARCH --override-os linux --retry-times 3 \
        docker://ghcr.io/cubeos-app/hal:latest \
        docker-archive:docker-images/cubeos-hal.tar:ghcr.io/cubeos-app/hal:latest
      IMG_COUNT=$((IMG_COUNT + 1))
      sleep 2

      echo "[core] CubeOS Dashboard..."
      skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" \
        --override-arch $DOCKER_ARCH --override-os linux --retry-times 3 \
        docker://ghcr.io/cubeos-app/dashboard:latest \
        docker-archive:docker-images/cubeos-dashboard.tar:ghcr.io/cubeos-app/dashboard:latest
      IMG_COUNT=$((IMG_COUNT + 1))
      sleep 2

      echo "[core] Docker Registry..."
      skopeo copy --override-arch $DOCKER_ARCH --override-os linux --retry-times 3 \
        docker://docker.io/library/registry:2 \
        docker-archive:docker-images/registry.tar:library/registry:2
      IMG_COUNT=$((IMG_COUNT + 1))
      sleep 2

      # ── Full-only images ─────────────────────────────────────────────
      if [ "$CUBEOS_VARIANT" = "full" ]; then
        echo "[full] CubeOS DocsIndex..."
        skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" \
          --override-arch $DOCKER_ARCH --override-os linux --retry-times 3 \
          docker://ghcr.io/cubeos-app/cubeos-docsindex:latest \
          docker-archive:docker-images/cubeos-docsindex.tar:ghcr.io/cubeos-app/cubeos-docsindex:latest
        IMG_COUNT=$((IMG_COUNT + 1))

        echo "[full] Dozzle..."
        skopeo copy --override-arch $DOCKER_ARCH --override-os linux --retry-times 3 \
          docker://docker.io/amir20/dozzle:latest \
          docker-archive:docker-images/dozzle.tar:amir20/dozzle:latest
        IMG_COUNT=$((IMG_COUNT + 1))

        echo "[full] Dufs (file browser)..."
        skopeo copy --override-arch $DOCKER_ARCH --override-os linux --retry-times 3 \
          docker://docker.io/sigoden/dufs:latest \
          docker-archive:docker-images/dufs.tar:sigoden/dufs:latest
        IMG_COUNT=$((IMG_COUNT + 1))

        echo "[full] ChromaDB..."
        skopeo copy --override-arch $DOCKER_ARCH --override-os linux --retry-times 3 \
          docker://docker.io/chromadb/chroma:latest \
          docker-archive:docker-images/chromadb.tar:chromadb/chroma:latest
        IMG_COUNT=$((IMG_COUNT + 1))
      else
        echo "[lite] Skipping full-only images (docsindex, dozzle, dufs, chromadb)"
      fi

      echo ""
      ls -lh docker-images/
      du -sh docker-images/
      echo "Docker images: OK (${IMG_COUNT} images for ${CUBEOS_VARIANT} variant)"
    - |
      set -e
      # Re-export IMAGE_NAME (each script block is a new shell)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then PLATFORM_SUFFIX="arm64"; elif [ "$CUBEOS_PLATFORM" = "x86_64" ]; then PLATFORM_SUFFIX="amd64"; else PLATFORM_SUFFIX="${CUBEOS_PLATFORM}-arm64"; fi
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${PLATFORM_SUFFIX}"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${PLATFORM_SUFFIX}"; fi
      export IMAGE_NAME PLATFORM_SUFFIX
      DOCKER_ARCH="${CUBEOS_ARCH:-arm64}"; export DOCKER_ARCH

      echo ""
      echo "============================================================"
      echo "  Phase 0b2: Download curated app images + ZIM content (${CUBEOS_VARIANT})"
      echo "============================================================"

      # Lite variant: skip curated apps and ZIM content entirely
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        echo "Lite variant: skipping curated images and ZIM content"
        mkdir -p curated-images  # empty dir so later phases don't fail
        echo "Phase 0b2: SKIPPED (lite)"
      else

      # --- Curated app images (for local registry) ---
      chmod +x skopeo/download-curated.sh
      # B56: Curated downloads MUST succeed. If kiwix-serve or ttyd fail to
      # download, Phase 1c silently skips ("No curated images found") and the
      # image ships with broken services showing 0/1 replicas.
      # B66: Enable verbose mode for CI debugging. Use set +e to capture
      # exit code without set -e killing the block prematurely.
      export CURATED_VERBOSE=true
      set +e
      ./skopeo/download-curated.sh curated-images
      CURATED_EXIT=$?
      set -e
      if [ "$CURATED_EXIT" -ne 0 ]; then
        echo "ERROR: Curated image download failed (exit $CURATED_EXIT)"
        echo "Cannot build image with broken curated apps."
        echo "Check network connectivity and image ARM64 manifests."
        echo ""
        echo "Debug: verify ARM64 manifests exist:"
        echo "  skopeo inspect --raw docker://ghcr.io/kiwix/kiwix-serve:3.8.1 | jq '.manifests[].platform'"
        echo "  skopeo inspect --raw docker://docker.io/tsl0922/ttyd:latest | jq '.manifests[].platform'"
        exit 1
      fi
      echo ""
      echo "Curated tarballs:"
      ls -lh curated-images/ 2>/dev/null || echo "  (no curated images)"
      # B66: Verify expected tarball count matches manifest entries
      EXPECTED_COUNT=$(grep -v '^[[:space:]]*#' skopeo/curated-apps.txt | grep -v '^$' | wc -l)
      ACTUAL_COUNT=$(ls curated-images/*.tar 2>/dev/null | wc -l)
      echo "  Expected: ${EXPECTED_COUNT} tarballs, Got: ${ACTUAL_COUNT}"
      if [ "$ACTUAL_COUNT" -lt "$EXPECTED_COUNT" ]; then
        echo "ERROR: Missing curated tarballs (${ACTUAL_COUNT}/${EXPECTED_COUNT})"
        exit 1
      fi

      # --- ZIM content for Kiwix (configurable) ---
      ZIM_ENABLED="${ZIM_ENABLED:-true}"
      ZIM_URL="${ZIM_URL:-https://download.kiwix.org/zim/wikipedia/wikipedia_en_100_maxi_2026-01.zim}"

      if [ "$ZIM_ENABLED" = "true" ]; then
        mkdir -p zim-content
        ZIM_FILENAME=$(basename "$ZIM_URL")
        echo "Downloading ZIM: ${ZIM_FILENAME}..."
        if wget -q --show-progress -O "zim-content/${ZIM_FILENAME}" "$ZIM_URL"; then
          echo "  ZIM OK: $(du -h "zim-content/${ZIM_FILENAME}" | cut -f1)"
        else
          echo "  WARN: ZIM download failed (non-fatal — Kiwix will show empty library)"
          rm -f "zim-content/${ZIM_FILENAME}"
        fi
      else
        echo "ZIM download disabled (ZIM_ENABLED=false)"
      fi
      echo "Phase 0b2: OK"
      fi  # end full-only curated/ZIM block
    - |
      set -e
      # Re-export IMAGE_NAME (each script block is a new shell)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then PLATFORM_SUFFIX="arm64"; elif [ "$CUBEOS_PLATFORM" = "x86_64" ]; then PLATFORM_SUFFIX="amd64"; else PLATFORM_SUFFIX="${CUBEOS_PLATFORM}-arm64"; fi
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${PLATFORM_SUFFIX}"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${PLATFORM_SUFFIX}"; fi
      export IMAGE_NAME PLATFORM_SUFFIX
      DOCKER_ARCH="${CUBEOS_ARCH:-arm64}"; export DOCKER_ARCH

      echo ""
      echo "============================================================"
      echo "  Phase 0c: Download golden base image"
      echo "============================================================"

      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           -o cubeos-base.img.xz \
           --connect-timeout 30 \
           --max-time 3600 \
           --retry 3 \
           --retry-delay 10 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos-base/${BASE_VERSION}/${BASE_IMAGE_NAME}.img.xz"
      ls -lh cubeos-base.img.xz
      echo "Base image: OK"
    - |
      set -e
      # Re-export IMAGE_NAME (each script block is a new shell)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then PLATFORM_SUFFIX="arm64"; elif [ "$CUBEOS_PLATFORM" = "x86_64" ]; then PLATFORM_SUFFIX="amd64"; else PLATFORM_SUFFIX="${CUBEOS_PLATFORM}-arm64"; fi
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${PLATFORM_SUFFIX}"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${PLATFORM_SUFFIX}"; fi
      export IMAGE_NAME PLATFORM_SUFFIX
      DOCKER_ARCH="${CUBEOS_ARCH:-arm64}"; export DOCKER_ARCH

      echo ""
      echo "============================================================"
      echo "  Phase 1: Packer build (${CUBEOS_VARIANT})"
      echo "  Started: $(date -u +%H:%M:%S)"
      echo "============================================================"

      chmod +x platforms/*/scripts/*.sh shared/scripts/*.sh firstboot/*.sh

      packer build \
        -var "version=${CUBEOS_VERSION}" \
        -var "variant=${CUBEOS_VARIANT}" \
        -var "image_size=${IMAGE_SIZE}" \
        -var "base_image_url=file://${CI_PROJECT_DIR}/cubeos-base.img.xz" \
        -var "base_image_checksum_type=none" \
        "${PACKER_TEMPLATE}"

      ls -lh ${IMAGE_NAME}.img
      echo "Packer build: OK ($(date -u +%H:%M:%S))"
    - |
      set -e
      # Re-export IMAGE_NAME (each script block is a new shell)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then PLATFORM_SUFFIX="arm64"; elif [ "$CUBEOS_PLATFORM" = "x86_64" ]; then PLATFORM_SUFFIX="amd64"; else PLATFORM_SUFFIX="${CUBEOS_PLATFORM}-arm64"; fi
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${PLATFORM_SUFFIX}"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${PLATFORM_SUFFIX}"; fi
      export IMAGE_NAME PLATFORM_SUFFIX
      DOCKER_ARCH="${CUBEOS_ARCH:-arm64}"; export DOCKER_ARCH

      echo ""
      echo "============================================================"
      echo "  Phase 1b: Pre-load Docker images into image (${CUBEOS_VARIANT})"
      echo "  Started: $(date -u +%H:%M:%S)"
      echo "============================================================"

      # ── Step 1: Mount the built image ──────────────────────────────
      LOOPDEV=$(losetup -fP --show ${IMAGE_NAME}.img)
      echo "Loop device: $LOOPDEV"
      sleep 2

      # Pi has 2 partitions (p1=boot, p2=root); Armbian has 1 (p1=root)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then
        ROOT_PART="${LOOPDEV}p2"
      else
        ROOT_PART="${LOOPDEV}p1"
      fi
      if [ ! -b "$ROOT_PART" ]; then
        echo "ERROR: Root partition ${ROOT_PART} not found"
        losetup -d "$LOOPDEV"
        exit 1
      fi

      mkdir -p /mnt/cubeos-image
      mount "$ROOT_PART" /mnt/cubeos-image
      echo "Mounted root partition at /mnt/cubeos-image (${CUBEOS_PLATFORM})"

      # Ensure /var/lib/docker exists on the image
      mkdir -p /mnt/cubeos-image/var/lib/docker

      # ── Step 2: Start temporary dockerd ────────────────────────────
      # Key flags for isolation from any existing daemon:
      #   --data-root     → writes to the MOUNTED IMAGE, not the CI host
      #   -H              → separate socket to avoid conflicts
      #   --pidfile       → separate PID file
      #   --exec-root     → separate runtime state
      #   --iptables=false --bridge=none → no host networking changes
      #   --containerd=""  → don't connect to containerd (avoid socket conflicts)
      echo "Starting temporary dockerd with --data-root /mnt/cubeos-image/var/lib/docker..."

      dockerd \
        --data-root /mnt/cubeos-image/var/lib/docker \
        --storage-driver overlay2 \
        -H unix:///tmp/cubeos-preload.sock \
        --pidfile /tmp/cubeos-preload.pid \
        --exec-root /tmp/cubeos-preload-exec \
        --iptables=false \
        --bridge=none \
        --containerd="" \
        &>/tmp/dockerd-preload.log &
      DOCKERD_PID=$!

      echo "Waiting for dockerd (PID: $DOCKERD_PID)..."
      for i in $(seq 1 60); do
        if docker -H unix:///tmp/cubeos-preload.sock info &>/dev/null; then
          echo "  dockerd ready (${i}s)"
          break
        fi
        if [ "$i" -eq 60 ]; then
          echo "ERROR: dockerd failed to start. Log:"
          tail -30 /tmp/dockerd-preload.log
          kill "$DOCKERD_PID" 2>/dev/null || true
          umount /mnt/cubeos-image 2>/dev/null || true
          losetup -d "$LOOPDEV" 2>/dev/null || true
          exit 1
        fi
        sleep 1
      done

      # ── Step 3: Load ARM64 tarballs ────────────────────────────────
      DOCKER_CMD="docker -H unix:///tmp/cubeos-preload.sock"
      LOADED=0
      FAILED=0

      for tarball in docker-images/*.tar; do
        [ -f "$tarball" ] || continue
        NAME=$(basename "$tarball" .tar)
        SIZE=$(du -h "$tarball" | cut -f1)
        echo "  Loading: ${NAME} (${SIZE})..."
        LOAD_START=$(date +%s)

        if $DOCKER_CMD load < "$tarball" 2>&1; then
          LOAD_END=$(date +%s)
          echo "    OK ($(( LOAD_END - LOAD_START ))s)"
          LOADED=$((LOADED + 1))
        else
          echo "    FAILED"
          FAILED=$((FAILED + 1))
        fi
      done

      # ── Step 3b: Load curated images + retag for localhost:5000 ─────
      # B85: Compose services (terminal, future curated apps) use
      # --pull never and reference images as localhost:5000/{repo}:{tag}.
      # Phase 1c pushes these to the registry, but --pull never won't
      # query the registry. We must also have them in Docker's local
      # image cache with the localhost:5000/ prefix tag.
      # Lite variant: skip curated images (only core images loaded).
      echo ""
      CURATED_LOADED=0
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        echo "  Lite variant: skipping curated image loading"
      else
      echo "  Loading curated images into Docker cache (B85 fix)..."
      for tarball in curated-images/*.tar; do
        [ -f "$tarball" ] || continue
        NAME=$(basename "$tarball" .tar)
        SIZE=$(du -h "$tarball" | cut -f1)
        echo "  Loading curated: ${NAME} (${SIZE})..."

        if $DOCKER_CMD load < "$tarball" 2>&1; then
          echo "    Loaded"
          CURATED_LOADED=$((CURATED_LOADED + 1))
        else
          echo "    FAILED (non-fatal — image will be in registry)"
        fi
      done

      # Retag curated images with localhost:5000/ prefix
      # (compose files reference localhost:5000/{repo}:{tag})
      if [ "$CURATED_LOADED" -gt 0 ] && [ -f skopeo/curated-apps.txt ]; then
        echo "  Retagging curated images for localhost:5000/..."
        while IFS= read -r line; do
          [[ "$line" =~ ^[[:space:]]*# ]] && continue
          [[ -z "${line// }" ]] && continue

          SOURCE_IMAGE=$(echo "$line" | cut -d'|' -f1 | xargs)
          TAG=$(echo "$line" | cut -d'|' -f2 | xargs)
          REPO_NAME=$(echo "$SOURCE_IMAGE" | sed 's|^docker\.io/||; s|^ghcr\.io/||')

          if $DOCKER_CMD tag "${REPO_NAME}:${TAG}" "localhost:5000/${REPO_NAME}:${TAG}" 2>/dev/null; then
            echo "    ${REPO_NAME}:${TAG} → localhost:5000/${REPO_NAME}:${TAG}"
          else
            echo "    WARN: Could not retag ${REPO_NAME}:${TAG} (image may not have loaded)"
          fi
        done < skopeo/curated-apps.txt
      fi
      fi  # end full-only curated block

      # ── Step 3c: Retag core images for localhost:5000 ─────────────
      # Registry-first: ALL images (except registry:2) get a localhost:5000/
      # prefix tag so Swarm services can reference them from the local registry.
      echo ""
      echo "  Retagging core images for localhost:5000/..."
      CORE_RETAGGED=0
      if [ -f skopeo/core-images.txt ]; then
        while IFS= read -r line; do
          [[ "$line" =~ ^[[:space:]]*# ]] && continue
          [[ -z "${line// }" ]] && continue

          SOURCE_IMAGE=$(echo "$line" | cut -d'|' -f1 | xargs)
          TAG=$(echo "$line" | cut -d'|' -f2 | xargs)

          # Strip registry host prefix: docker.io/ or ghcr.io/
          REPO_NAME=$(echo "$SOURCE_IMAGE" | sed 's|^docker\.io/||; s|^ghcr\.io/||')

          # Determine the tag the image was loaded with in Step 3.
          # Docker Hub images load as repo:tag, GHCR images load as ghcr.io/repo:tag
          if echo "$SOURCE_IMAGE" | grep -q "^ghcr\.io/"; then
            LOADED_TAG="${SOURCE_IMAGE}:${TAG}"
          else
            LOADED_TAG="${REPO_NAME}:${TAG}"
          fi

          if $DOCKER_CMD tag "${LOADED_TAG}" "localhost:5000/${REPO_NAME}:${TAG}" 2>/dev/null; then
            echo "    ${LOADED_TAG} → localhost:5000/${REPO_NAME}:${TAG}"
            CORE_RETAGGED=$((CORE_RETAGGED + 1))
          else
            echo "    WARN: Could not retag ${LOADED_TAG} (image may not have loaded)"
          fi
        done < skopeo/core-images.txt
      fi
      echo "  Core images retagged: ${CORE_RETAGGED}"

      echo ""
      echo "Pre-load results: ${LOADED} core + ${CURATED_LOADED} curated loaded, ${CORE_RETAGGED} core retagged, ${FAILED} failed"
      $DOCKER_CMD images --format "  {{.Repository}}:{{.Tag}} ({{.Size}})"

      if [ "$FAILED" -gt 0 ]; then
        echo "WARNING: ${FAILED} images failed to load!"
        tail -20 /tmp/dockerd-preload.log
      fi

      # ── Step 4: Graceful shutdown ──────────────────────────────────
      # CRITICAL: Must use SIGTERM (not SIGKILL) to flush metadata to disk.
      # overlay2 metadata databases must be written out cleanly or the
      # Pi's dockerd will see a corrupted store on first boot.
      echo "Shutting down temporary dockerd..."
      kill -SIGTERM "$DOCKERD_PID"
      wait "$DOCKERD_PID" 2>/dev/null || true
      echo "  dockerd shut down cleanly"

      # ── Step 5: Cleanup ────────────────────────────────────────────
      # Remove the tarball cache from the image — no longer needed
      rm -rf /mnt/cubeos-image/var/cache/cubeos-images
      echo "  Removed tarball cache from image (images are in overlay2 now)"

      # Verify overlay2 data exists
      echo "  Docker storage size: $(du -sh /mnt/cubeos-image/var/lib/docker/ | cut -f1)"
      ls /mnt/cubeos-image/var/lib/docker/overlay2/ | wc -l | xargs -I{} echo "  overlay2 layers: {}"

      sync
      umount /mnt/cubeos-image
      losetup -d "$LOOPDEV" || true
      rmdir /mnt/cubeos-image 2>/dev/null || true

      echo "Docker pre-load complete: ${LOADED} core + ${CURATED_LOADED} curated images baked into ${IMAGE_NAME}.img"
      echo "Phase 1b: OK ($(date -u +%H:%M:%S))"
    - |
      set -e
      # Re-export IMAGE_NAME (each script block is a new shell)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then PLATFORM_SUFFIX="arm64"; elif [ "$CUBEOS_PLATFORM" = "x86_64" ]; then PLATFORM_SUFFIX="amd64"; else PLATFORM_SUFFIX="${CUBEOS_PLATFORM}-arm64"; fi
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${PLATFORM_SUFFIX}"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${PLATFORM_SUFFIX}"; fi
      export IMAGE_NAME PLATFORM_SUFFIX
      DOCKER_ARCH="${CUBEOS_ARCH:-arm64}"; export DOCKER_ARCH

      echo ""
      echo "============================================================"
      echo "  Phase 1c: Pre-populate local registry + ZIM content (${CUBEOS_VARIANT})"
      echo "  Started: $(date -u +%H:%M:%S)"
      echo "============================================================"

      # Skip if no images at all (core + curated)
      CORE_IMAGE_COUNT=$(find docker-images -maxdepth 1 -name '*.tar' 2>/dev/null | wc -l || echo 0)
      CURATED_COUNT=$(find curated-images -maxdepth 1 -name '*.tar' 2>/dev/null | wc -l || echo 0)
      if [ "$CORE_IMAGE_COUNT" -eq 0 ] && [ "$CURATED_COUNT" -eq 0 ]; then
        echo "No images found — skipping Phase 1c"
      else
        # ── Step 1: Mount the built image ──────────────────────────────
        LOOPDEV=$(losetup -fP --show ${IMAGE_NAME}.img)
        echo "Loop device: $LOOPDEV"
        sleep 2

        # Pi has 2 partitions (p1=boot, p2=root); Armbian has 1 (p1=root)
        if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then
          ROOT_PART="${LOOPDEV}p2"
        else
          ROOT_PART="${LOOPDEV}p1"
        fi
        if [ ! -b "$ROOT_PART" ]; then
          echo "ERROR: Root partition ${ROOT_PART} not found"
          losetup -d "$LOOPDEV"
          exit 1
        fi

        mkdir -p /mnt/cubeos-image
        mount "$ROOT_PART" /mnt/cubeos-image
        echo "Mounted root partition at /mnt/cubeos-image (${CUBEOS_PLATFORM})"

        # ── Step 2: Ensure registry data directory exists ──────────────
        mkdir -p /mnt/cubeos-image/cubeos/data/registry

        # ── Step 2.5: Ensure registry:2 available on CI Docker ─────────
        # B56: Phase 1b loaded registry.tar into the mounted image's dockerd
        # (via custom socket). Phase 1c uses the CI host's Docker to run the
        # temp registry container — it needs registry:2 locally.
        if ! docker image inspect registry:2 &>/dev/null; then
            echo "  Loading registry:2 into CI Docker (B56 fix)..."
            docker load < docker-images/registry.tar 2>&1 || {
                echo "ERROR: Failed to load registry:2 — cannot populate local registry"
                sync
                umount /mnt/cubeos-image
                losetup -d "$LOOPDEV"
                exit 1
            }
        fi
        echo "  registry:2 available on CI Docker: OK"

        # ── Step 3: Start temp registry:2 against local storage ──────
        # B66v2: Previous approach used -v volume mount to map the mounted
        # image partition into the temp registry container. This FAILS in
        # Docker-in-Docker (GitLab CI): the -v path is interpreted from the
        # Docker HOST's perspective, not the CI container's mount namespace.
        # The CI container loop-mounts the image at /mnt/cubeos-image, but
        # the Docker host has nothing at that path — so the registry writes
        # to an empty dir on the host. Validation passes (queries the running
        # registry) but data never reaches the disk image.
        #
        # FIX: Start registry WITHOUT a host volume. Push images to it.
        # Then use `docker cp` to extract the registry data back into the
        # CI container's mount namespace (which sees the real partition).
        echo "Starting temporary registry:2 (no volume — will docker cp after push)..."
        docker rm -f cubeos-temp-registry 2>/dev/null || true

        docker run -d --name cubeos-temp-registry \
          -p 5099:5099 \
          -e REGISTRY_STORAGE_DELETE_ENABLED=true \
          -e REGISTRY_HTTP_ADDR=:5099 \
          registry:2

        # Discover reachable URL. In DinD, port-mapped container binds to
        # the Docker host — find container IP as fallback.
        REGISTRY_URL=""
        sleep 3

        # Try localhost first (works when not in DinD)
        if curl -sf "http://127.0.0.1:5099/v2/" &>/dev/null; then
          REGISTRY_URL="http://127.0.0.1:5099"
          echo "  Registry reachable at localhost:5099"
        else
          # DinD fallback: get container IP on bridge network
          CONTAINER_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' cubeos-temp-registry 2>/dev/null || true)
          if [ -n "$CONTAINER_IP" ] && curl -sf "http://${CONTAINER_IP}:5099/v2/" &>/dev/null; then
            REGISTRY_URL="http://${CONTAINER_IP}:5099"
            echo "  Registry reachable at container IP ${CONTAINER_IP}:5099"
          fi
        fi

        if [ -z "$REGISTRY_URL" ]; then
          echo "ERROR: Cannot reach temp registry at localhost:5099 or container IP"
          docker logs cubeos-temp-registry 2>&1 | tail -10
          docker rm -f cubeos-temp-registry 2>/dev/null || true
          umount /mnt/cubeos-image
          losetup -d "$LOOPDEV"
          exit 1
        fi

        echo "  Registry URL: ${REGISTRY_URL}"
        sleep 2

        # Wait for registry to be ready
        for i in $(seq 1 30); do
          if curl -sf "${REGISTRY_URL}/v2/" &>/dev/null; then
            echo "  Temp registry ready (${i}s)"
            break
          fi
          if [ "$i" -eq 30 ]; then
            echo "ERROR: Temp registry failed to start"
            docker logs cubeos-temp-registry 2>&1 | tail -10
            docker rm -f cubeos-temp-registry 2>/dev/null || true
            umount /mnt/cubeos-image
            losetup -d "$LOOPDEV"
            exit 1
          fi
          sleep 1
        done

        # ── Step 3.5: Push core images into registry ─────────────────
        # Registry-first: push ALL core images (except registry:2) so
        # services can pull from localhost:5000 on boot.
        CORE_PUSHED=0
        CORE_PUSH_FAILED=0
        # Extract host:port from REGISTRY_URL for docker:// transport
        REGISTRY_HOST=$(echo "$REGISTRY_URL" | sed 's|http://||')

        if [ -f skopeo/core-images.txt ]; then
          echo "Pushing core images into registry..."
          while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue

            SOURCE_IMAGE=$(echo "$line" | cut -d'|' -f1 | xargs)
            TAG=$(echo "$line" | cut -d'|' -f2 | xargs)
            FILENAME=$(echo "$line" | cut -d'|' -f3 | xargs)
            TARBALL="docker-images/${FILENAME}"

            # Strip registry host prefix for the repo name in our local registry
            REPO_NAME=$(echo "$SOURCE_IMAGE" | sed 's|^docker\.io/||; s|^ghcr\.io/||')

            if [ ! -f "$TARBALL" ]; then
              if [ "$CUBEOS_VARIANT" = "lite" ]; then
                echo "  SKIP (lite): ${TARBALL} not present — expected for lite variant"
              else
                echo "  SKIP: ${TARBALL} not found"
                CORE_PUSH_FAILED=$((CORE_PUSH_FAILED + 1))
              fi
              continue
            fi

            echo "  Pushing ${REPO_NAME}:${TAG} → registry..."
            if skopeo copy \
              --override-arch $DOCKER_ARCH \
              --override-os linux \
              --dest-tls-verify=false \
              "docker-archive:${TARBALL}" \
              "docker://${REGISTRY_HOST}/${REPO_NAME}:${TAG}" 2>&1; then
              echo "    OK"
              CORE_PUSHED=$((CORE_PUSHED + 1))
            else
              echo "    FAILED"
              CORE_PUSH_FAILED=$((CORE_PUSH_FAILED + 1))
            fi
          done < skopeo/core-images.txt
        fi

        echo ""
        echo "Core registry push results: ${CORE_PUSHED} pushed, ${CORE_PUSH_FAILED} failed"

        if [ "$CORE_PUSH_FAILED" -gt 0 ]; then
            echo "ERROR: ${CORE_PUSH_FAILED} core images failed to push to registry!"
            docker stop cubeos-temp-registry 2>/dev/null || true
            docker rm cubeos-temp-registry 2>/dev/null || true
            sync
            umount /mnt/cubeos-image
            losetup -d "$LOOPDEV"
            exit 1
        fi

        # ── Step 4: Push curated images into registry ──────────────────
        PUSHED=0
        PUSH_FAILED=0

        if [ "$CUBEOS_VARIANT" = "full" ]; then
          # Read manifest to get repo:tag mapping for each tarball
          while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue

            SOURCE_IMAGE=$(echo "$line" | cut -d'|' -f1 | xargs)
            TAG=$(echo "$line" | cut -d'|' -f2 | xargs)
            FILENAME=$(echo "$line" | cut -d'|' -f3 | xargs)
            TARBALL="curated-images/${FILENAME}"

            # Strip registry host prefix for the repo name in our local registry
            REPO_NAME=$(echo "$SOURCE_IMAGE" | sed 's|^docker\.io/||; s|^ghcr\.io/||')

            if [ ! -f "$TARBALL" ]; then
              echo "  SKIP: ${TARBALL} not found"
              PUSH_FAILED=$((PUSH_FAILED + 1))
              continue
            fi

            echo "  Pushing ${REPO_NAME}:${TAG} → registry..."
            if skopeo copy \
              --override-arch $DOCKER_ARCH \
              --override-os linux \
              --dest-tls-verify=false \
              "docker-archive:${TARBALL}" \
              "docker://${REGISTRY_HOST}/${REPO_NAME}:${TAG}" 2>&1; then
              echo "    OK"
              PUSHED=$((PUSHED + 1))
            else
              echo "    FAILED"
              PUSH_FAILED=$((PUSH_FAILED + 1))
            fi
          done < skopeo/curated-apps.txt

          echo ""
          echo "Curated registry push results: ${PUSHED} pushed, ${PUSH_FAILED} failed"

          # B56: Fail build if any curated image failed to push — silent failures
          # previously caused kiwix to show 0/1 replicas on boot.
          if [ "$PUSH_FAILED" -gt 0 ]; then
              echo "ERROR: ${PUSH_FAILED} curated images failed to push to registry!"
              echo "Kiwix and other curated apps will not work on the built image."
              docker stop cubeos-temp-registry 2>/dev/null || true
              docker rm cubeos-temp-registry 2>/dev/null || true
              sync
              umount /mnt/cubeos-image
              losetup -d "$LOOPDEV"
              exit 1
          fi
        else
          echo "Lite variant: skipping curated image push"
        fi

        TOTAL_PUSHED=$((CORE_PUSHED + PUSHED))
        TOTAL_PUSH_FAILED=$((CORE_PUSH_FAILED + PUSH_FAILED))
        CORE_COUNT=$(grep -cv '^\s*#\|^\s*$' skopeo/core-images.txt)
        if [ "$CUBEOS_VARIANT" = "full" ]; then
          CURATED_COUNT=$(grep -cv '^\s*#\|^\s*$' skopeo/curated-apps.txt)
          EXPECTED=$((CORE_COUNT + CURATED_COUNT))
          echo "Total registry push: ${TOTAL_PUSHED} pushed, ${TOTAL_PUSH_FAILED} failed (${CORE_COUNT} core + ${CURATED_COUNT} curated = ${EXPECTED} expected)"
        else
          echo "Total registry push: ${TOTAL_PUSHED} pushed, ${TOTAL_PUSH_FAILED} failed (${CORE_COUNT} core expected)"
        fi

        # ── Step 5: Validate registry contents ─────────────────────────
        if [ "$CUBEOS_VARIANT" = "full" ]; then
          CORE_COUNT=$(grep -cv '^\s*#\|^\s*$' skopeo/core-images.txt)
          CURATED_COUNT=$(grep -cv '^\s*#\|^\s*$' skopeo/curated-apps.txt)
          EXPECTED=$((CORE_COUNT + CURATED_COUNT))
          echo ""
          echo "Validating registry contents (${EXPECTED} expected: ${CORE_COUNT} core + ${CURATED_COUNT} curated)..."
        else
          # Lite: count only tarballs that were actually downloaded
          CORE_COUNT=$(find docker-images -maxdepth 1 -name '*.tar' 2>/dev/null | wc -l || echo 0)
          EXPECTED=${CORE_COUNT}
          echo ""
          echo "Validating registry contents (${EXPECTED} expected: ${CORE_COUNT} core)..."
        fi
        CATALOG=$(curl -sf "${REGISTRY_URL}/v2/_catalog" 2>/dev/null || echo '{"repositories":[]}')
        echo "  Catalog: ${CATALOG}"

        # Helper function: validate manifest has config digest
        validate_image() {
          local repo_name="$1" tag="$2"
          MANIFEST_RESP=$(curl -sf \
            -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
            "${REGISTRY_URL}/v2/${repo_name}/manifests/${tag}" 2>/dev/null || echo "")

          if [ -n "$MANIFEST_RESP" ]; then
            CONFIG_DIGEST=$(echo "$MANIFEST_RESP" | grep -o '"digest"[[:space:]]*:[[:space:]]*"sha256:[a-f0-9]*"' | head -1 | grep -o 'sha256:[a-f0-9]*' || echo "")

            if [ -n "$CONFIG_DIGEST" ]; then
              echo "  VALID: ${repo_name}:${tag} (config: ${CONFIG_DIGEST:0:19}...)"
              return 0
            else
              echo "  INVALID: ${repo_name}:${tag} (no config digest in manifest)"
              return 1
            fi
          else
            echo "  INVALID: ${repo_name}:${tag} (manifest not found)"
            return 1
          fi
        }

        VALID=0
        INVALID=0

        # Validate core images
        echo "  --- Core images ---"
        while IFS= read -r line; do
          [[ "$line" =~ ^[[:space:]]*# ]] && continue
          [[ -z "${line// }" ]] && continue

          SOURCE_IMAGE=$(echo "$line" | cut -d'|' -f1 | xargs)
          TAG=$(echo "$line" | cut -d'|' -f2 | xargs)
          FILENAME=$(echo "$line" | cut -d'|' -f3 | xargs)
          REPO_NAME=$(echo "$SOURCE_IMAGE" | sed 's|^docker\.io/||; s|^ghcr\.io/||')

          # Lite variant: skip images whose tarballs were never downloaded
          if [ "$CUBEOS_VARIANT" = "lite" ] && [ ! -f "docker-images/${FILENAME}" ]; then
            echo "  SKIP (lite): ${REPO_NAME}:${TAG}"
            continue
          fi

          if validate_image "$REPO_NAME" "$TAG"; then
            VALID=$((VALID + 1))
          else
            INVALID=$((INVALID + 1))
          fi
        done < skopeo/core-images.txt

        # Validate curated images (full only)
        if [ "$CUBEOS_VARIANT" = "full" ]; then
          echo "  --- Curated images ---"
          while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue

            SOURCE_IMAGE=$(echo "$line" | cut -d'|' -f1 | xargs)
            TAG=$(echo "$line" | cut -d'|' -f2 | xargs)
            REPO_NAME=$(echo "$SOURCE_IMAGE" | sed 's|^docker\.io/||; s|^ghcr\.io/||')

            if validate_image "$REPO_NAME" "$TAG"; then
              VALID=$((VALID + 1))
            else
              INVALID=$((INVALID + 1))
            fi
          done < skopeo/curated-apps.txt
        fi

        echo "  Validated: ${VALID}/${EXPECTED} images"
        if [ "$INVALID" -gt 0 ]; then
          echo "ERROR: ${INVALID} images failed validation!"
          docker stop cubeos-temp-registry 2>/dev/null || true
          docker rm cubeos-temp-registry 2>/dev/null || true
          sync
          umount /mnt/cubeos-image
          losetup -d "$LOOPDEV"
          exit 1
        fi

        # ── Step 6: Copy registry data to mounted image, then stop ────
        # B66v2: Registry data lives inside the container (no volume mount).
        # Use docker cp to extract it to the mounted image partition.
        echo "Copying registry data from container to image..."
        rm -rf /mnt/cubeos-image/cubeos/data/registry/*
        docker cp cubeos-temp-registry:/var/lib/registry/. /mnt/cubeos-image/cubeos/data/registry/

        # Verify data was actually copied
        COPY_SIZE=$(du -sh /mnt/cubeos-image/cubeos/data/registry/ 2>/dev/null | cut -f1)
        REPO_COUNT=$(find /mnt/cubeos-image/cubeos/data/registry/docker/registry/v2/repositories -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
        echo "  Copied: ${COPY_SIZE} (${REPO_COUNT} repositories on disk)"

        if [ "$REPO_COUNT" -eq 0 ]; then
          echo "ERROR: docker cp produced empty registry — no repositories on disk!"
          docker logs cubeos-temp-registry 2>&1 | tail -10
          docker rm -f cubeos-temp-registry 2>/dev/null || true
          sync
          umount /mnt/cubeos-image
          losetup -d "$LOOPDEV"
          exit 1
        fi

        echo "Stopping temp registry..."
        docker stop cubeos-temp-registry 2>/dev/null || true
        docker rm cubeos-temp-registry 2>/dev/null || true

        # Verify registry storage on disk
        REGISTRY_SIZE=$(du -sh /mnt/cubeos-image/cubeos/data/registry/ 2>/dev/null | cut -f1)
        echo "  Registry storage on disk: ${REGISTRY_SIZE}"

        # ── Step 7: Copy ZIM content into image ───────────────────────
        if [ -d "zim-content" ] && ls zim-content/*.zim &>/dev/null; then
          echo ""
          echo "Copying ZIM files into image..."
          mkdir -p /mnt/cubeos-image/cubeos/data/kiwix
          cp zim-content/*.zim /mnt/cubeos-image/cubeos/data/kiwix/
          # Kiwix container runs as UID 1001 — ensure it can read the files
          chown -R 1001:1001 /mnt/cubeos-image/cubeos/data/kiwix/
          ZIM_SIZE=$(du -sh /mnt/cubeos-image/cubeos/data/kiwix/ | cut -f1)
          echo "  ZIM content: ${ZIM_SIZE}"
        else
          echo ""
          echo "No ZIM files to copy (Kiwix will show empty library)"
          mkdir -p /mnt/cubeos-image/cubeos/data/kiwix
          chown -R 1001:1001 /mnt/cubeos-image/cubeos/data/kiwix/
        fi

        # ── Step 8: Unmount ────────────────────────────────────────────
        sync
        umount /mnt/cubeos-image
        losetup -d "$LOOPDEV"
        rmdir /mnt/cubeos-image 2>/dev/null || true

        echo ""
        echo "Phase 1c: OK — ${TOTAL_PUSHED} images in registry (${CORE_PUSHED} core + ${PUSHED} curated), ZIM content copied"
        echo "Phase 1c: OK ($(date -u +%H:%M:%S))"
      fi
    - |
      set -e
      # Re-export IMAGE_NAME (each script block is a new shell)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then PLATFORM_SUFFIX="arm64"; elif [ "$CUBEOS_PLATFORM" = "x86_64" ]; then PLATFORM_SUFFIX="amd64"; else PLATFORM_SUFFIX="${CUBEOS_PLATFORM}-arm64"; fi
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${PLATFORM_SUFFIX}"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${PLATFORM_SUFFIX}"; fi
      export IMAGE_NAME PLATFORM_SUFFIX
      DOCKER_ARCH="${CUBEOS_ARCH:-arm64}"; export DOCKER_ARCH

      echo ""
      echo "============================================================"
      echo "  Phase 1d: Post-Build File Validation (${CUBEOS_VARIANT})"
      echo "============================================================"
      # Loopback-mount the built image and verify critical files exist.
      # Catches missing boot scripts, broken configs, wrong version, etc.
      # BEFORE compression — cheapest place to catch errors.

      LOOPDEV=$(losetup -fP --show ${IMAGE_NAME}.img)
      echo "Loop device: $LOOPDEV"
      sleep 2

      # Pi has 2 partitions (p1=boot, p2=root); Armbian has 1 (p1=root)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then
        ROOT_PART="${LOOPDEV}p2"
        BOOT_PART="${LOOPDEV}p1"
      else
        ROOT_PART="${LOOPDEV}p1"
        BOOT_PART=""
      fi
      MOUNT_DIR="/mnt/cubeos-validate"
      mkdir -p "$MOUNT_DIR"
      mount -o ro "$ROOT_PART" "$MOUNT_DIR"
      if [ -n "$BOOT_PART" ] && [ -b "$BOOT_PART" ]; then
        mount -o ro "$BOOT_PART" "$MOUNT_DIR/boot/firmware" 2>/dev/null || true
      fi

      VALIDATION_ERRORS=0
      val_check() {
        local label="$1" path="$2"
        if [ -e "${MOUNT_DIR}${path}" ]; then
          echo "  OK: ${label}"
        else
          echo "  FAIL: ${label} — ${path} missing"
          VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
        fi
      }

      echo ""
      echo "[1/6] Boot scripts..."
      val_check "cubeos-boot-lib.sh"       "/usr/local/bin/cubeos-boot-lib.sh"
      val_check "cubeos-first-boot.sh"     "/usr/local/bin/cubeos-first-boot.sh"
      val_check "cubeos-normal-boot.sh"    "/usr/local/bin/cubeos-normal-boot.sh"
      val_check "cubeos-boot-detect.sh"    "/usr/local/bin/cubeos-boot-detect.sh"
      val_check "cubeos-generate-secrets.sh" "/usr/local/bin/cubeos-generate-secrets.sh"
      val_check "cubeos-deploy-stacks.sh"  "/usr/local/bin/cubeos-deploy-stacks.sh"

      echo ""
      echo "[2/6] Systemd & services..."
      val_check "Docker daemon.json"       "/etc/docker/daemon.json"
      val_check "Netplan config"           "/etc/netplan/01-cubeos.yaml"
      # hostapd is Pi-only (BananaPi/Pine64 have no onboard WiFi)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then
        val_check "hostapd config"           "/etc/hostapd/hostapd.conf"
      fi

      echo ""
      echo "[3/6] Security hardening (Phase 1.3)..."
      val_check "SSH 01-cubeos.conf"             "/etc/ssh/sshd_config.d/01-cubeos.conf"
      val_check "SSH 99-cubeos-hardening.conf"   "/etc/ssh/sshd_config.d/99-cubeos-hardening.conf"
      val_check "sysctl 99-cubeos.conf"          "/etc/sysctl.d/99-cubeos.conf"
      val_check "sysctl 99-cubeos-security.conf" "/etc/sysctl.d/99-cubeos-security.conf"
      val_check "journald cubeos.conf"           "/etc/systemd/journald.conf.d/cubeos.conf"
      val_check "watchdog cubeos-watchdog.conf"  "/etc/systemd/system.conf.d/cubeos-watchdog.conf"
      val_check "fail2ban cubeos-sshd.conf"      "/etc/fail2ban/jail.d/cubeos-sshd.conf"

      echo ""
      echo "[4/6] CubeOS directories & config..."
      val_check "/cubeos/config/defaults.env"    "/cubeos/config/defaults.env"
      val_check "/cubeos/data/"                  "/cubeos/data/"
      val_check "/cubeos/coreapps/"              "/cubeos/coreapps/"
      val_check "/cubeos/docs/"                  "/cubeos/docs/"

      echo ""
      echo "[5/6] Compose files..."
      val_check "pihole compose"      "/cubeos/coreapps/pihole/appconfig/docker-compose.yml"
      val_check "npm compose"         "/cubeos/coreapps/npm/appconfig/docker-compose.yml"
      val_check "cubeos-api compose"  "/cubeos/coreapps/cubeos-api/appconfig/docker-compose.yml"
      val_check "cubeos-hal compose"  "/cubeos/coreapps/cubeos-hal/appconfig/docker-compose.yml"
      val_check "cubeos-dashboard compose" "/cubeos/coreapps/cubeos-dashboard/appconfig/docker-compose.yml"

      echo ""
      echo "[6/6] Version & metadata..."
      val_check "/etc/cubeos-version"  "/etc/cubeos-version"
      if [ -f "${MOUNT_DIR}/etc/cubeos-version" ]; then
        BAKED_VERSION=$(cat "${MOUNT_DIR}/etc/cubeos-version")
        if [ "$BAKED_VERSION" = "$CUBEOS_VERSION" ]; then
          echo "  OK: Version matches ($BAKED_VERSION)"
        else
          echo "  FAIL: Version mismatch — baked=$BAKED_VERSION expected=$CUBEOS_VERSION"
          VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
        fi
      fi

      # Spot-check security content (not just file existence)
      echo ""
      echo "[SPOT] Content verification..."
      if grep -q "PermitRootLogin no" "${MOUNT_DIR}/etc/ssh/sshd_config.d/99-cubeos-hardening.conf" 2>/dev/null; then
        echo "  OK: SSH PermitRootLogin=no"
      else
        echo "  FAIL: SSH PermitRootLogin not set to no"
        VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
      fi
      if grep -q "Storage=volatile" "${MOUNT_DIR}/etc/systemd/journald.conf.d/cubeos.conf" 2>/dev/null; then
        echo "  OK: journald Storage=volatile"
      else
        echo "  FAIL: journald not set to volatile"
        VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
      fi
      if grep -q "RuntimeWatchdogSec=10s" "${MOUNT_DIR}/etc/systemd/system.conf.d/cubeos-watchdog.conf" 2>/dev/null; then
        echo "  OK: watchdog RuntimeWatchdogSec=10s"
      else
        echo "  FAIL: watchdog not configured"
        VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
      fi

      # Cleanup
      if [ -n "${BOOT_PART:-}" ]; then
        umount "$MOUNT_DIR/boot/firmware" 2>/dev/null || true
      fi
      umount "$MOUNT_DIR"
      losetup -d "$LOOPDEV"
      rmdir "$MOUNT_DIR" 2>/dev/null || true

      echo ""
      if [ "$VALIDATION_ERRORS" -gt 0 ]; then
        echo "============================================================"
        echo "  VALIDATION FAILED: $VALIDATION_ERRORS errors detected"
        echo "  Image will NOT be compressed. Fix the build and retry."
        echo "============================================================"
        exit 1
      else
        echo "============================================================"
        echo "  Phase 1d: PASSED — All files verified"
        echo "============================================================"
      fi
    - |
      set -e
      # Re-export IMAGE_NAME (each script block is a new shell)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then PLATFORM_SUFFIX="arm64"; elif [ "$CUBEOS_PLATFORM" = "x86_64" ]; then PLATFORM_SUFFIX="amd64"; else PLATFORM_SUFFIX="${CUBEOS_PLATFORM}-arm64"; fi
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${PLATFORM_SUFFIX}"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${PLATFORM_SUFFIX}"; fi
      export IMAGE_NAME PLATFORM_SUFFIX
      DOCKER_ARCH="${CUBEOS_ARCH:-arm64}"; export DOCKER_ARCH

      echo ""
      echo "============================================================"
      echo "  Phase 2: Shrink + Compress (${CUBEOS_VARIANT})"
      echo "============================================================"

      # PiShrink
      echo "[1/5] Running PiShrink..."
      wget -q -O pishrink.sh https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh || echo "WARN PiShrink download failed, skipping"
      if [ -f pishrink.sh ]; then
        chmod +x pishrink.sh
        timeout 300 bash pishrink.sh -s ${IMAGE_NAME}.img || echo "WARN: PiShrink failed or timed out (non-fatal — zerofree runs next)"
      fi

      # Zerofree
      echo "[2/5] Running zerofree..."
      LOOPDEV=$(losetup -fP --show ${IMAGE_NAME}.img)
      echo "Loop device: $LOOPDEV"
      sleep 2
      # Pi: p2=root; Armbian: p1=root
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then ROOT_PART="${LOOPDEV}p2"; else ROOT_PART="${LOOPDEV}p1"; fi
      if [ -b "$ROOT_PART" ]; then
        e2fsck -fy "$ROOT_PART" || true
        zerofree -v "$ROOT_PART" || echo "WARN zerofree failed (non-fatal)"
      fi
      losetup -d "$LOOPDEV"

      # XZ compress
      echo "[3/5] Compressing with xz -6 (multi-threaded)..."
      ls -lh ${IMAGE_NAME}.img
      xz -6 -T0 -v ${IMAGE_NAME}.img

      # Checksums (standard + Pi Imager)
      echo "[4/5] Calculating checksums..."
      sha256sum ${IMAGE_NAME}.img.xz > ${IMAGE_NAME}.img.xz.sha256
      md5sum ${IMAGE_NAME}.img.xz > ${IMAGE_NAME}.img.xz.md5
      # Pi Imager needs both compressed and extracted checksums
      # calculate-checksums.sh requires uncompressed .img — decompress temporarily
      echo "[5/5] Generating Pi Imager checksums..."
      xz -dk ${IMAGE_NAME}.img.xz  # decompress, keep .xz
      chmod +x scripts/calculate-checksums.sh
      bash scripts/calculate-checksums.sh ${IMAGE_NAME}
      rm -f ${IMAGE_NAME}.img  # remove uncompressed copy
    - |
      set -e
      # Re-export IMAGE_NAME (each script block is a new shell)
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then PLATFORM_SUFFIX="arm64"; elif [ "$CUBEOS_PLATFORM" = "x86_64" ]; then PLATFORM_SUFFIX="amd64"; else PLATFORM_SUFFIX="${CUBEOS_PLATFORM}-arm64"; fi
      if [ "$CUBEOS_VARIANT" = "lite" ]; then IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${PLATFORM_SUFFIX}"; else IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${PLATFORM_SUFFIX}"; fi
      export IMAGE_NAME PLATFORM_SUFFIX
      DOCKER_ARCH="${CUBEOS_ARCH:-arm64}"; export DOCKER_ARCH

      echo ""
      echo "============================================================"
      echo "  Phase 3: Upload to GitLab Package Registry (${CUBEOS_VARIANT})"
      echo "============================================================"

      echo "Uploading ${IMAGE_NAME}..."
      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           --upload-file ${IMAGE_NAME}.img.xz \
           --connect-timeout 30 \
           --max-time 3600 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz"
      echo "  Image uploaded."

      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           --upload-file ${IMAGE_NAME}.img.xz.sha256 \
           --connect-timeout 30 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz.sha256"
      echo "  SHA256 uploaded."

      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           --upload-file ${IMAGE_NAME}.img.xz.md5 \
           --connect-timeout 30 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz.md5"
      echo "  MD5 uploaded."

      echo ""
      echo "============================================================"
      echo "  CubeOS Release Image — Build Complete (${CUBEOS_VARIANT})"
      echo "============================================================"
      echo "  Version   ${CUBEOS_VERSION}"
      echo "  Variant   ${CUBEOS_VARIANT}"
      echo "  File      ${IMAGE_NAME}.img.xz"
      echo "  Size      $(du -h ${IMAGE_NAME}.img.xz | cut -f1)"
      echo "  SHA256    $(cut -d' ' -f1 ${IMAGE_NAME}.img.xz.sha256)"
      echo "  Base      cubeos-base/${BASE_VERSION}"
      echo "============================================================"
  artifacts:
    paths:
      - "cubeos-*.img.xz.sha256"
      - "cubeos-*.img.xz.md5"
      - "cubeos-*.img.sha256"
    expire_in: 30 days
  after_script:
    - docker rm -f cubeos-temp-registry 2>/dev/null || true
    - umount /mnt/cubeos-image 2>/dev/null || true
    - losetup -D 2>/dev/null || true
  timeout: 60m

# =============================================================================
# Post-Build Validation (downloads compressed image, mounts, inspects filesystem)
# =============================================================================
# Runs AFTER build uploads to Package Registry. Downloads the compressed image,
# decompresses, loop-mounts, and validates critical files WITHOUT booting.
# This is the gate between build and release — if validation fails, no release.
# =============================================================================
validate-image:
  stage: validate
  image: ubuntu:24.04
  needs:
    - job: build-image
      artifacts: true
  parallel:
    matrix:
      - CUBEOS_PLATFORM: "raspberrypi"
        CUBEOS_VARIANT: "full"
        CUBEOS_ARCH: "arm64"
      - CUBEOS_PLATFORM: "raspberrypi"
        CUBEOS_VARIANT: "lite"
        CUBEOS_ARCH: "arm64"
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "push"'
    - if: '$CI_PIPELINE_SOURCE == "web"'
  script:
    - |
      set -e

      # ── Compute IMAGE_NAME (same logic as build-image) ─────────────
      if [ "$CUBEOS_PLATFORM" = "raspberrypi" ]; then
        PLATFORM_SUFFIX="arm64"
      elif [ "$CUBEOS_PLATFORM" = "x86_64" ]; then
        PLATFORM_SUFFIX="amd64"
      else
        PLATFORM_SUFFIX="${CUBEOS_PLATFORM}-arm64"
      fi
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${PLATFORM_SUFFIX}"
      else
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${PLATFORM_SUFFIX}"
      fi
      export IMAGE_NAME PLATFORM_SUFFIX

      echo "============================================================"
      echo "  CubeOS Post-Build Validation"
      echo "============================================================"
      echo "  Platform: ${CUBEOS_PLATFORM}"
      echo "  Variant:  ${CUBEOS_VARIANT}"
      echo "  Image:    ${IMAGE_NAME}"
      echo "============================================================"
      echo ""

      # ── Install tools ──────────────────────────────────────────────
      apt-get update -q 2>&1 | tail -3
      apt-get install -y -q xz-utils util-linux curl e2fsprogs 2>&1 | tail -5

      # ── Download compressed image from Package Registry ────────────
      echo "Downloading ${IMAGE_NAME}.img.xz from Package Registry..."
      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           -o "${IMAGE_NAME}.img.xz" \
           --connect-timeout 30 \
           --max-time 3600 \
           --retry 3 \
           --retry-delay 10 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz"
      ls -lh "${IMAGE_NAME}.img.xz"
      echo "Download: OK"

      # ── Decompress ─────────────────────────────────────────────────
      echo ""
      echo "Decompressing ${IMAGE_NAME}.img.xz..."
      xz -d "${IMAGE_NAME}.img.xz"
      ls -lh "${IMAGE_NAME}.img"
      echo "Decompress: OK"

      # ── Run validation script ──────────────────────────────────────
      echo ""
      chmod +x scripts/validate-image.sh
      export REPORT_FILE="${CI_PROJECT_DIR}/validation-report-${CUBEOS_VARIANT}.txt"
      scripts/validate-image.sh \
        "${IMAGE_NAME}.img" \
        "${CUBEOS_PLATFORM}" \
        "${CUBEOS_VARIANT}" \
        "${CUBEOS_VERSION}"

      echo ""
      echo "Validation complete. Report saved to: ${REPORT_FILE}"
  artifacts:
    paths:
      - "validation-report-*.txt"
    when: always
    expire_in: 30 days
  timeout: 15m

# =============================================================================
# QEMU Boot Test (x86_64 only — ARM64 emulation is too slow/flaky for CI)
# =============================================================================
# Downloads the x86_64 qcow2 image from Package Registry, boots it in QEMU
# with KVM acceleration, and verifies the OS reaches a usable state by
# monitoring serial console output for systemd targets or a login prompt.
#
# This is a real boot test, not just filesystem inspection. It catches issues
# that validate-image cannot: broken GRUB, kernel panics, missing initramfs
# modules, systemd dependency cycles, etc.
#
# Requires: KVM-capable runner (same as build-image-x86)
# Time: ~3 minutes (download + decompress + 120s max boot wait)
# =============================================================================
boot-test-x86:
  stage: boot-test
  image: ubuntu:24.04
  tags:
    - kvm
  needs:
    - job: build-image-x86
      artifacts: false
      optional: true
  rules:
    # Match build-image-x86 triggers (without manual gate — runs automatically
    # after the manual x86 build completes)
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "web"'
    - changes:
        - platforms/x86_64/**/*
        - shared/**/*
  script:
    - |
      set -e

      IMAGE_NAME="cubeos-${CUBEOS_VERSION}-amd64"
      IMAGE_FILE="${IMAGE_NAME}.qcow2"
      SERIAL_LOG="${CI_PROJECT_DIR}/boot-test-serial.log"
      TIMEOUT=120

      echo "============================================================"
      echo "  CubeOS x86_64 QEMU Boot Test"
      echo "============================================================"
      echo "  Image:   ${IMAGE_FILE}"
      echo "  Timeout: ${TIMEOUT}s"
      echo "============================================================"
      echo ""

      # ── Install QEMU ──────────────────────────────────────────────
      echo "Installing QEMU..."
      apt-get update -q 2>&1 | tail -3
      apt-get install -y -q qemu-system-x86 qemu-utils xz-utils curl 2>&1 | tail -5
      echo "  qemu-system-x86_64: $(qemu-system-x86_64 --version | head -1)"

      # ── Verify KVM access ─────────────────────────────────────────
      if [ -c /dev/kvm ]; then
        echo "  KVM: available (/dev/kvm present)"
        KVM_FLAGS="-enable-kvm -cpu host"
      else
        echo "  WARNING: /dev/kvm not found — using software emulation (slow)"
        echo "  Boot test may timeout without KVM acceleration."
        KVM_FLAGS=""
      fi

      # ── Download image from Package Registry ──────────────────────
      echo ""
      echo "Downloading ${IMAGE_FILE}.xz from Package Registry..."
      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           -o "${IMAGE_FILE}.xz" \
           --connect-timeout 30 \
           --max-time 1800 \
           --retry 3 \
           --retry-delay 10 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_FILE}.xz"
      ls -lh "${IMAGE_FILE}.xz"
      echo "Download: OK"

      # ── Decompress ────────────────────────────────────────────────
      echo ""
      echo "Decompressing ${IMAGE_FILE}.xz..."
      xz -d "${IMAGE_FILE}.xz"
      ls -lh "${IMAGE_FILE}"
      echo "Decompress: OK"

      # ── Boot QEMU ─────────────────────────────────────────────────
      echo ""
      echo "Booting QEMU..."
      touch "${SERIAL_LOG}"

      # shellcheck disable=SC2086
      qemu-system-x86_64 \
        -m 512 \
        ${KVM_FLAGS} \
        -drive file="${IMAGE_FILE}",format=qcow2,if=virtio \
        -netdev user,id=net0 \
        -device virtio-net-pci,netdev=net0 \
        -display none \
        -serial file:"${SERIAL_LOG}" \
        -no-reboot \
        -daemonize \
        -pidfile /tmp/qemu.pid

      QEMU_PID=$(cat /tmp/qemu.pid)
      echo "  QEMU started (PID: ${QEMU_PID})"

      # ── Poll serial output for boot success ───────────────────────
      BOOT_SUCCESS=false
      ELAPSED=0

      while [ "$ELAPSED" -lt "$TIMEOUT" ]; do
        sleep 5
        ELAPSED=$((ELAPSED + 5))

        # Check if QEMU is still running
        if ! kill -0 "$QEMU_PID" 2>/dev/null; then
          echo "  QEMU exited after ${ELAPSED}s (possible kernel panic or reboot)"
          break
        fi

        if [ -f "$SERIAL_LOG" ]; then
          # Primary: systemd reached multi-user.target
          if grep -qi "reached target.*multi.user" "$SERIAL_LOG" 2>/dev/null; then
            echo "  SUCCESS: systemd reached multi-user.target (${ELAPSED}s)"
            BOOT_SUCCESS=true
            break
          fi

          # Secondary: login prompt visible
          if grep -q "login:" "$SERIAL_LOG" 2>/dev/null; then
            echo "  SUCCESS: login prompt detected (${ELAPSED}s)"
            BOOT_SUCCESS=true
            break
          fi

          # Progress indicator
          LINE_COUNT=$(wc -l < "$SERIAL_LOG" 2>/dev/null || echo 0)
          LAST_LINE=$(tail -1 "$SERIAL_LOG" 2>/dev/null | head -c 120 || true)
          echo "  [${ELAPSED}s] ${LINE_COUNT} lines — ${LAST_LINE}"
        fi
      done

      # ── Cleanup: always kill QEMU ─────────────────────────────────
      echo ""
      echo "Stopping QEMU..."
      kill "$QEMU_PID" 2>/dev/null || true
      sleep 2
      kill -9 "$QEMU_PID" 2>/dev/null || true

      # ── Show tail of serial log ───────────────────────────────────
      echo ""
      echo "============================================================"
      echo "  Serial console output (last 50 lines)"
      echo "============================================================"
      tail -50 "$SERIAL_LOG" 2>/dev/null || echo "(no serial output captured)"

      # ── Result ────────────────────────────────────────────────────
      echo ""
      echo "============================================================"
      if $BOOT_SUCCESS; then
        echo "  BOOT TEST: PASSED"
        echo "============================================================"
        exit 0
      else
        echo "  BOOT TEST: FAILED"
        echo "============================================================"
        echo ""
        echo "  No success indicators detected within ${TIMEOUT}s."
        echo "  Expected one of:"
        echo "    - systemd multi-user.target reached"
        echo "    - login prompt on serial console"
        echo ""
        echo "  Full serial log saved as CI artifact."
        exit 1
      fi
  artifacts:
    paths:
      - "boot-test-serial.log"
    when: always
    expire_in: 7 days
  timeout: 5m

# =============================================================================
# Build x86_64 Image (separate job — requires KVM runner + different CI image)
# =============================================================================
# x86_64 uses the QEMU builder (not packer-builder-arm chroot), so it needs
# a different CI image and a runner with KVM support. Kept separate from the
# Pi matrix to avoid breaking the proven Pi build pipeline.
#
# STATUS: Manual trigger only — x86_64 support is experimental.
# =============================================================================
build-image-x86:
  stage: build
  image: hashicorp/packer:latest
  variables:
    CUBEOS_PLATFORM: "x86_64"
    CUBEOS_VARIANT: "full"
    CUBEOS_ARCH: "amd64"
    IMAGE_SIZE: "20G"
    PACKER_TEMPLATE: "platforms/x86_64/packer.pkr.hcl"
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
    - changes:
        - platforms/x86_64/**/*
        - shared/**/*
      when: manual
  tags:
    - kvm
  script:
    - |
      set -e
      echo "============================================================"
      echo "  CubeOS x86_64 Build (experimental)"
      echo "============================================================"

      apk add --no-cache qemu qemu-system-x86_64 qemu-img curl jq xz

      packer init "${PACKER_TEMPLATE}"
      packer build \
        -var "version=${CUBEOS_VERSION}" \
        -var "variant=${CUBEOS_VARIANT}" \
        -var "image_size=${IMAGE_SIZE}" \
        "${PACKER_TEMPLATE}"

      # Output image is in output-cubeos-x86/
      IMAGE_FILE=$(find output-cubeos-x86 -name "*.qcow2" | head -1)
      if [ -z "$IMAGE_FILE" ]; then
        echo "ERROR: No qcow2 image found in output-cubeos-x86/"
        exit 1
      fi

      echo "Built: $IMAGE_FILE ($(du -h "$IMAGE_FILE" | cut -f1))"

      # Compress
      IMAGE_BASE=$(basename "$IMAGE_FILE" .qcow2)
      xz -6 -T0 -v "$IMAGE_FILE"
      sha256sum "${IMAGE_FILE}.xz" > "${IMAGE_FILE}.xz.sha256"

      echo "Compressed: ${IMAGE_FILE}.xz ($(du -h "${IMAGE_FILE}.xz" | cut -f1))"

      # Upload to Package Registry
      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           --upload-file "${IMAGE_FILE}.xz" \
           --connect-timeout 30 \
           --max-time 1800 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_BASE}.qcow2.xz"
      echo "Uploaded to Package Registry."
  artifacts:
    paths:
      - "output-cubeos-x86/*.xz.sha256"
    expire_in: 30 days
  timeout: 90m
  allow_failure: true

# =============================================================================
# Manual Armbian Platform Builds (placeholder — trigger individually from UI)
# =============================================================================
# These platforms have Packer templates but are NOT verified on hardware yet.
# Base image URLs in their packer.pkr.hcl files are TODO placeholders.
# To build: click "Play" on the specific platform job in GitLab CI/CD > Pipelines.
# Each downloads its own Armbian base image — no golden base needed.
# =============================================================================
build-image-arm-manual:
  stage: build
  image:
    name: mkaczanowski/packer-builder-arm:latest
    entrypoint: [""]
  parallel:
    matrix:
      - CUBEOS_PLATFORM: "bananapi"
        CUBEOS_ARCH: "arm64"
        IMAGE_SIZE: "12G"
        PACKER_TEMPLATE: "platforms/bananapi/packer.pkr.hcl"
      - CUBEOS_PLATFORM: "bananapim4zero"
        CUBEOS_ARCH: "arm64"
        IMAGE_SIZE: "12G"
        PACKER_TEMPLATE: "platforms/bananapim4zero/packer.pkr.hcl"
      - CUBEOS_PLATFORM: "pine64"
        CUBEOS_ARCH: "arm64"
        IMAGE_SIZE: "12G"
        PACKER_TEMPLATE: "platforms/pine64/packer.pkr.hcl"
      - CUBEOS_PLATFORM: "orangepi5"
        CUBEOS_ARCH: "arm64"
        IMAGE_SIZE: "12G"
        PACKER_TEMPLATE: "platforms/orangepi5/packer.pkr.hcl"
      - CUBEOS_PLATFORM: "rock5b"
        CUBEOS_ARCH: "arm64"
        IMAGE_SIZE: "12G"
        PACKER_TEMPLATE: "platforms/rock5b/packer.pkr.hcl"
      - CUBEOS_PLATFORM: "quartz64b"
        CUBEOS_ARCH: "arm64"
        IMAGE_SIZE: "10G"
        PACKER_TEMPLATE: "platforms/quartz64b/packer.pkr.hcl"
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
    - if: '$CI_PIPELINE_SOURCE == "push"'
      when: manual
  allow_failure: true
  script:
    - |
      set -e

      echo "============================================================"
      echo "  CubeOS Armbian Build — ${CUBEOS_PLATFORM} (${CUBEOS_VARIANT:-full})"
      echo "============================================================"

      CUBEOS_VARIANT="${CUBEOS_VARIANT:-full}"

      # Compute image name
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${CUBEOS_PLATFORM}-arm64"
      else
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${CUBEOS_PLATFORM}-arm64"
      fi
      export IMAGE_NAME
      echo "Platform: ${CUBEOS_PLATFORM}"
      echo "Image:    ${IMAGE_NAME}"
      echo "Template: ${PACKER_TEMPLATE}"

      # Validate CI variables
      if [ -z "${GHCR_USER:-}" ] || [ -z "${GHCR_TOKEN:-}" ]; then
        echo "ERROR: GHCR_USER and GHCR_TOKEN CI variables are required."
        exit 1
      fi

      # QEMU binfmt for ARM64 emulation on x86 CI runner
      mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc || true
      if [ ! -f /proc/sys/fs/binfmt_misc/qemu-aarch64 ]; then
        echo "ERROR: QEMU aarch64 binfmt not registered on host!"
        exit 1
      fi
      echo "QEMU aarch64 binfmt: OK"

      # Install tools
      apt-get update -q 2>&1 | tail -3 || true
      apt-get install -y -q docker.io skopeo xz-utils zerofree e2fsprogs parted wget kpartx util-linux curl jq git zstd 2>&1 | tail -5

    - |
      set -e
      CUBEOS_VARIANT="${CUBEOS_VARIANT:-full}"
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${CUBEOS_PLATFORM}-arm64"
      else
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${CUBEOS_PLATFORM}-arm64"
      fi
      export IMAGE_NAME

      echo "============================================================"
      echo "  Phase 0a: Clone coreapps repo"
      echo "============================================================"

      git clone --depth 1 \
        "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/products/cubeos/coreapps.git" \
        /tmp/coreapps-src

      # Use full service list (same as Pi full variant)
      SERVICES="pihole npm cubeos-api cubeos-hal cubeos-dashboard cubeos-docsindex registry dozzle terminal kiwix filebrowser chromadb"

      mkdir -p coreapps-bundle
      for svc in $SERVICES; do
        if [ -d "/tmp/coreapps-src/${svc}/appconfig" ]; then
          mkdir -p "coreapps-bundle/${svc}"
          cp -r "/tmp/coreapps-src/${svc}/appconfig" "coreapps-bundle/${svc}/"
          echo "  + ${svc}/appconfig"
        fi
      done

      if [ -d "/tmp/coreapps-src/scripts" ]; then
        cp -r /tmp/coreapps-src/scripts coreapps-bundle/
        chmod +x coreapps-bundle/scripts/*.sh 2>/dev/null || true
      fi
      rm -rf /tmp/coreapps-src

    - |
      set -e
      CUBEOS_VARIANT="${CUBEOS_VARIANT:-full}"
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${CUBEOS_PLATFORM}-arm64"
      else
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${CUBEOS_PLATFORM}-arm64"
      fi
      export IMAGE_NAME

      echo "============================================================"
      echo "  Phase 0b: Download ARM64 Docker images"
      echo "============================================================"

      mkdir -p docker-images

      echo "[core] Pi-hole..."
      skopeo copy --override-arch arm64 --override-os linux --retry-times 3 \
        docker://docker.io/pihole/pihole:latest \
        docker-archive:docker-images/pihole.tar:pihole/pihole:latest
      sleep 2

      echo "[core] Nginx Proxy Manager..."
      skopeo copy --override-arch arm64 --override-os linux --retry-times 3 \
        docker://docker.io/jc21/nginx-proxy-manager:latest \
        docker-archive:docker-images/npm.tar:jc21/nginx-proxy-manager:latest
      sleep 2

      echo "[core] CubeOS API..."
      skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" \
        --override-arch arm64 --override-os linux --retry-times 3 \
        docker://ghcr.io/cubeos-app/api:latest \
        docker-archive:docker-images/cubeos-api.tar:ghcr.io/cubeos-app/api:latest
      sleep 2

      echo "[core] CubeOS HAL..."
      skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" \
        --override-arch arm64 --override-os linux --retry-times 3 \
        docker://ghcr.io/cubeos-app/hal:latest \
        docker-archive:docker-images/cubeos-hal.tar:ghcr.io/cubeos-app/hal:latest
      sleep 2

      echo "[core] CubeOS Dashboard..."
      skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" \
        --override-arch arm64 --override-os linux --retry-times 3 \
        docker://ghcr.io/cubeos-app/dashboard:latest \
        docker-archive:docker-images/cubeos-dashboard.tar:ghcr.io/cubeos-app/dashboard:latest
      sleep 2

      echo "[core] Docker Registry..."
      skopeo copy --override-arch arm64 --override-os linux --retry-times 3 \
        docker://docker.io/library/registry:2 \
        docker-archive:docker-images/registry.tar:library/registry:2

      echo ""
      ls -lh docker-images/
      echo "Docker images: OK"

    - |
      set -e
      CUBEOS_VARIANT="${CUBEOS_VARIANT:-full}"
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${CUBEOS_PLATFORM}-arm64"
      else
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${CUBEOS_PLATFORM}-arm64"
      fi
      export IMAGE_NAME

      echo "============================================================"
      echo "  Phase 1: Packer build (${CUBEOS_PLATFORM})"
      echo "============================================================"

      chmod +x platforms/*/scripts/*.sh shared/scripts/*.sh firstboot/*.sh

      # NOTE: Armbian templates download their own base image via base_image_url
      # in the Packer HCL — no golden base download needed (unlike Pi).
      packer build \
        -var "version=${CUBEOS_VERSION}" \
        -var "variant=${CUBEOS_VARIANT:-full}" \
        -var "image_size=${IMAGE_SIZE}" \
        "${PACKER_TEMPLATE}"

      ls -lh *.img
      echo "Packer build: OK"

    - |
      set -e
      CUBEOS_VARIANT="${CUBEOS_VARIANT:-full}"
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${CUBEOS_PLATFORM}-arm64"
      else
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${CUBEOS_PLATFORM}-arm64"
      fi
      export IMAGE_NAME

      echo "============================================================"
      echo "  Phase 2: Compress (${CUBEOS_PLATFORM})"
      echo "============================================================"

      ls -lh ${IMAGE_NAME}.img
      xz -6 -T0 -v ${IMAGE_NAME}.img
      sha256sum ${IMAGE_NAME}.img.xz > ${IMAGE_NAME}.img.xz.sha256

      echo "Compressed: $(du -h ${IMAGE_NAME}.img.xz | cut -f1)"
      echo "SHA256: $(cat ${IMAGE_NAME}.img.xz.sha256)"

    - |
      set -e
      CUBEOS_VARIANT="${CUBEOS_VARIANT:-full}"
      if [ "$CUBEOS_VARIANT" = "lite" ]; then
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-lite-${CUBEOS_PLATFORM}-arm64"
      else
        IMAGE_NAME="cubeos-${CUBEOS_VERSION}-${CUBEOS_PLATFORM}-arm64"
      fi
      export IMAGE_NAME

      echo "============================================================"
      echo "  Phase 3: Upload to Package Registry (${CUBEOS_PLATFORM})"
      echo "============================================================"

      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           --upload-file ${IMAGE_NAME}.img.xz \
           --connect-timeout 30 \
           --max-time 1800 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos-${CUBEOS_PLATFORM}/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz"
      echo "  Image uploaded."

      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           --upload-file ${IMAGE_NAME}.img.xz.sha256 \
           --connect-timeout 30 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos-${CUBEOS_PLATFORM}/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz.sha256"
      echo "  SHA256 uploaded."

      echo ""
      echo "============================================================"
      echo "  Build Complete: ${CUBEOS_PLATFORM}"
      echo "============================================================"
      echo "  Version:  ${CUBEOS_VERSION}"
      echo "  Platform: ${CUBEOS_PLATFORM}"
      echo "  File:     ${IMAGE_NAME}.img.xz"
      echo "  Size:     $(du -h ${IMAGE_NAME}.img.xz | cut -f1)"
      echo "  SHA256:   $(cut -d' ' -f1 ${IMAGE_NAME}.img.xz.sha256)"
      echo "============================================================"
  artifacts:
    paths:
      - "cubeos-*.img.xz.sha256"
    expire_in: 30 days
  timeout: 60m

# =============================================================================
# Upload to DMZ Releases Servers (every push to main)
# =============================================================================
# Downloads built images from Package Registry, uploads to both DMZ nodes
# (NL + GR), creates SHA256 checksum file, and sets up "latest" symlinks.
#
# Required CI variables:
#   CI_DEPLOY_SSH_KEY  — SSH private key for DMZ access
#   DMZ_HOST_NL        — NL DMZ hostname (e.g., nllei01dmz01)
#   DMZ_HOST_GR        — GR DMZ hostname (e.g., grath01dmz01)
# =============================================================================
upload-to-dmz:
  stage: upload
  image: alpine:latest
  variables:
    FULL_IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-arm64"
    LITE_IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-lite-arm64"
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
  needs:
    - job: "validate-image: [raspberrypi, full, arm64]"
      artifacts: false
      optional: true
    - job: "validate-image: [raspberrypi, lite, arm64]"
      artifacts: false
      optional: true
  before_script:
    - apk add --no-cache openssh-client rsync curl jq
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - echo "$CI_DEPLOY_SSH_KEY" | tr -d '\r' > ~/.ssh/id_ed25519 && chmod 600 ~/.ssh/id_ed25519
    - ssh-keyscan -H ${DMZ_HOST_NL:-localhost} >> ~/.ssh/known_hosts 2>/dev/null || true
    - ssh-keyscan -H ${DMZ_HOST_GR:-localhost} >> ~/.ssh/known_hosts 2>/dev/null || true
  script:
    - |
      set -e
      SSH_OPTS="-i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no -o ConnectTimeout=10"

      echo "============================================================"
      echo "  Upload CubeOS ${CUBEOS_VERSION} to DMZ release servers"
      echo "============================================================"

      # ── Download images from Package Registry ──────────────────────
      download_pkg() {
        local filename="$1"
        echo "Downloading ${filename} from Package Registry..."
        curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
             -o "${filename}" \
             --connect-timeout 30 \
             --max-time 3600 \
             --retry 3 \
             --retry-delay 30 \
             "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${filename}"
      }

      download_pkg "${FULL_IMAGE_NAME}.img.xz"
      download_pkg "${FULL_IMAGE_NAME}.img.xz.sha256"
      download_pkg "${LITE_IMAGE_NAME}.img.xz"
      download_pkg "${LITE_IMAGE_NAME}.img.xz.sha256"

      # Verify checksums before upload
      echo ""
      echo "Verifying checksums..."
      sha256sum -c "${FULL_IMAGE_NAME}.img.xz.sha256"
      sha256sum -c "${LITE_IMAGE_NAME}.img.xz.sha256"
      echo "Checksums: OK"

      # Generate combined checksums file
      cat "${FULL_IMAGE_NAME}.img.xz.sha256" "${LITE_IMAGE_NAME}.img.xz.sha256" > checksums.sha256
      echo "Generated checksums.sha256"

      FULL_FILENAME="${FULL_IMAGE_NAME}.img.xz"
      LITE_FILENAME="${LITE_IMAGE_NAME}.img.xz"

      # ── Upload to each DMZ node ────────────────────────────────────
      UPLOAD_COUNT=0
      for DMZ in ${DMZ_HOST_NL:-} ${DMZ_HOST_GR:-}; do
        [ -z "$DMZ" ] && continue
        echo ""
        echo "Uploading to ${DMZ}..."

        # Create version directory (o+rx so nginx in container can traverse)
        ssh $SSH_OPTS kyriakosp@${DMZ} "mkdir -p -m 755 /srv/cubeos-releases/data/${CUBEOS_VERSION}"

        # Upload images + checksums
        rsync -e "ssh $SSH_OPTS" -av --chmod=D755,F644 --progress \
          "${FULL_FILENAME}" \
          "${FULL_IMAGE_NAME}.img.xz.sha256" \
          "${LITE_FILENAME}" \
          "${LITE_IMAGE_NAME}.img.xz.sha256" \
          checksums.sha256 \
          kyriakosp@${DMZ}:/srv/cubeos-releases/data/${CUBEOS_VERSION}/

        # Update "latest" symlinks
        ssh $SSH_OPTS kyriakosp@${DMZ} "
          ln -sf /srv/cubeos-releases/data/${CUBEOS_VERSION}/${FULL_FILENAME} \
                 /srv/cubeos-releases/data/latest-full.img.xz
          ln -sf /srv/cubeos-releases/data/${CUBEOS_VERSION}/${LITE_FILENAME} \
                 /srv/cubeos-releases/data/latest-lite.img.xz
          ln -sf /srv/cubeos-releases/data/${CUBEOS_VERSION}/checksums.sha256 \
                 /srv/cubeos-releases/data/latest-checksums.sha256
        "
        echo "  ${DMZ}: OK"
        UPLOAD_COUNT=$((UPLOAD_COUNT + 1))
      done

      if [ "$UPLOAD_COUNT" -eq 0 ]; then
        echo "WARN: No DMZ hosts configured (DMZ_HOST_NL / DMZ_HOST_GR not set)"
        echo "Images are in Package Registry only."
      fi

      # Export URLs for downstream jobs
      echo "FULL_URL=https://releases.cubeos.app/${CUBEOS_VERSION}/${FULL_FILENAME}" > upload.env
      echo "LITE_URL=https://releases.cubeos.app/${CUBEOS_VERSION}/${LITE_FILENAME}" >> upload.env
      echo "FULL_FILENAME=${FULL_FILENAME}" >> upload.env
      echo "LITE_FILENAME=${LITE_FILENAME}" >> upload.env

      echo ""
      echo "============================================================"
      echo "  Upload complete — ${UPLOAD_COUNT} DMZ node(s)"
      echo "  Full: https://releases.cubeos.app/${CUBEOS_VERSION}/${FULL_FILENAME}"
      echo "  Lite: https://releases.cubeos.app/${CUBEOS_VERSION}/${LITE_FILENAME}"
      echo "============================================================"
  artifacts:
    reports:
      dotenv: upload.env
    expire_in: 7 days
  allow_failure: true
  timeout: 60m

# =============================================================================
# Create GitHub Pre-Release with DMZ Download Links (every push to main)
# =============================================================================
create-github-prerelease:
  stage: upload
  image: alpine:latest
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
  needs:
    - job: upload-to-dmz
      artifacts: true
      optional: true
    - job: generate-changelog
      artifacts: true
      optional: true
  variables:
    GH_REPO: "cubeos-app/releases"
  script:
    - apk add --no-cache curl jq
    - |
      set -e

      if [ -z "${GHCR_TOKEN:-}" ]; then
        echo "WARN: GHCR_TOKEN not set — skipping GitHub pre-release."
        exit 0
      fi

      echo "============================================================"
      echo "  Create GitHub Pre-Release for v${CUBEOS_VERSION}"
      echo "============================================================"

      # Compute URLs from CUBEOS_VERSION directly (do not rely on dotenv)
      FULL_FILENAME="cubeos-${CUBEOS_VERSION}-arm64.img.xz"
      LITE_FILENAME="cubeos-${CUBEOS_VERSION}-lite-arm64.img.xz"
      FULL_URL="https://releases.cubeos.app/${CUBEOS_VERSION}/${FULL_FILENAME}"
      LITE_URL="https://releases.cubeos.app/${CUBEOS_VERSION}/${LITE_FILENAME}"
      CHECKSUMS_URL="https://releases.cubeos.app/${CUBEOS_VERSION}/checksums.sha256"

      # Download lite image from GitLab Package Registry to upload as GitHub asset
      echo "Downloading ${LITE_FILENAME} from Package Registry..."
      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           -o "${LITE_FILENAME}" \
           --connect-timeout 30 \
           --retry 3 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${LITE_FILENAME}"
      LITE_SIZE=$(stat -c%s "${LITE_FILENAME}")
      echo "  Downloaded ${LITE_FILENAME} ($(( LITE_SIZE / 1048576 )) MiB)"

      # Also download lite checksum
      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           -o "${LITE_FILENAME}.sha256" \
           --connect-timeout 30 \
           --retry 3 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${LITE_FILENAME}.sha256"

      LITE_SHA256=$(cut -d' ' -f1 "${LITE_FILENAME}.sha256")

      RELEASE_BODY="## CubeOS v${CUBEOS_VERSION}

      Flashable ARM64 image for Raspberry Pi 4/5 (Ubuntu 24.04.3 based).

      ### Download

      | Variant | Link | Size |
      |---------|------|------|
      | **Full** (recommended) | [Download from releases.cubeos.app](${FULL_URL}) | ~2.3 GB |
      | **Lite** | Attached below as Release Asset | ~1.8 GB |

      **SHA256 Checksums:** [checksums.sha256](${CHECKSUMS_URL})

      Lite SHA256: \`${LITE_SHA256}\`

      ### Install via curl (any Linux machine)
      \`\`\`bash
      curl -fsSL https://get.cubeos.app | sudo bash
      \`\`\`

      ### Flash to Raspberry Pi
      1. Download the image (Full or Lite)
      2. Flash to SD card using [Raspberry Pi Imager](https://www.raspberrypi.com/software/) → Use custom
      3. Boot the Pi — connect to the CubeOS WiFi AP
      4. Open http://cubeos.cube and complete setup wizard"

      # Append changelog if available from generate-changelog job
      if [ -f "changelog-entry.md" ] && [ -s "changelog-entry.md" ]; then
        CHANGELOG_CONTENT=$(cat changelog-entry.md)
        RELEASE_BODY="${RELEASE_BODY}

      ### What's New

      ${CHANGELOG_CONTENT}

      Full changelog: [get.cubeos.app/changelog](https://get.cubeos.app/changelog/)"
        echo "  Changelog appended to release body."
      fi

      # Check if release already exists (tag may be pushed by mirror before this job runs)
      EXISTING=$(curl -s \
        -H "Authorization: token ${GHCR_TOKEN}" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/${GH_REPO}/releases/tags/v${CUBEOS_VERSION}")

      EXISTING_ID=$(echo "$EXISTING" | jq -r '.id // empty')

      if [ -n "$EXISTING_ID" ]; then
        echo "Updating existing release (ID: ${EXISTING_ID})..."
        curl -s -X PATCH \
          -H "Authorization: token ${GHCR_TOKEN}" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${GH_REPO}/releases/${EXISTING_ID}" \
          -d "$(jq -n \
            --arg name "CubeOS v${CUBEOS_VERSION}" \
            --arg body "${RELEASE_BODY}" \
            '{name: $name, body: $body, prerelease: true}'
          )" > /dev/null
        RELEASE_ID="$EXISTING_ID"
        echo "  Release updated."
      else
        echo "Creating new pre-release..."
        RELEASE_RESPONSE=$(curl -s -X POST \
          -H "Authorization: token ${GHCR_TOKEN}" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${GH_REPO}/releases" \
          -d "$(jq -n \
            --arg tag "v${CUBEOS_VERSION}" \
            --arg name "CubeOS v${CUBEOS_VERSION}" \
            --arg body "${RELEASE_BODY}" \
            '{tag_name: $tag, name: $name, body: $body, draft: false, prerelease: true}'
          )")
        RELEASE_ID=$(echo "$RELEASE_RESPONSE" | jq -r '.id')
        echo "  Pre-release created (ID: ${RELEASE_ID})."
      fi

      # Delete any existing lite asset (from a previous failed/retried run)
      EXISTING_ASSETS=$(curl -s \
        -H "Authorization: token ${GHCR_TOKEN}" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/${GH_REPO}/releases/${RELEASE_ID}/assets")
      OLD_ASSET_ID=$(echo "$EXISTING_ASSETS" | jq -r ".[] | select(.name == \"${LITE_FILENAME}\") | .id // empty")
      if [ -n "$OLD_ASSET_ID" ]; then
        echo "  Deleting old asset (ID: ${OLD_ASSET_ID})..."
        curl -s -X DELETE \
          -H "Authorization: token ${GHCR_TOKEN}" \
          "https://api.github.com/repos/${GH_REPO}/releases/assets/${OLD_ASSET_ID}" > /dev/null
      fi

      # Upload lite image as release asset
      echo "Uploading ${LITE_FILENAME} as release asset..."
      curl --fail -X POST \
        -H "Authorization: token ${GHCR_TOKEN}" \
        -H "Content-Type: application/x-xz" \
        --data-binary "@${LITE_FILENAME}" \
        "https://uploads.github.com/repos/${GH_REPO}/releases/${RELEASE_ID}/assets?name=${LITE_FILENAME}" > /dev/null
      echo "  Lite image uploaded."

      echo "  https://github.com/${GH_REPO}/releases/tag/v${CUBEOS_VERSION}"
  allow_failure: true

# =============================================================================
# Generate Changelog (every push to main)
# =============================================================================
# Generates changelog from conventional commits across repos using GitLab
# Compare API. Outputs changelog-entry.md (single version) and CHANGELOG.md
# (full history) as artifacts. Pushes updated files to releases + website repos.
# =============================================================================
generate-changelog:
  stage: upload
  image: alpine:latest
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
  needs: []
  script:
    - apk add --no-cache curl jq bash git
    - |
      set -e

      if [ -z "${GITLAB_TOKEN:-}" ]; then
        echo "WARN: GITLAB_TOKEN not set — skipping changelog generation."
        exit 0
      fi

      echo "============================================================"
      echo "  Generate Changelog for v${CUBEOS_VERSION}"
      echo "============================================================"

      export GITLAB_TOKEN

      # Generate single version entry (for GitHub release body)
      chmod +x scripts/generate-changelog.sh
      bash scripts/generate-changelog.sh > changelog-entry.md 2>/dev/null || {
        echo "WARN: Changelog entry generation failed — continuing with empty entry."
        echo "*Changelog generation failed for this version.*" > changelog-entry.md
      }
      echo "  changelog-entry.md: $(wc -l < changelog-entry.md) lines"

      # Generate full changelog
      bash scripts/generate-changelog.sh --full > CHANGELOG.md 2>/dev/null || {
        echo "WARN: Full changelog generation failed — using single entry."
        cp changelog-entry.md CHANGELOG.md
      }
      echo "  CHANGELOG.md: $(wc -l < CHANGELOG.md) lines"

      # Push updated CHANGELOG.md to releases repo
      echo "Pushing CHANGELOG.md to releases repo..."
      git clone --depth 1 https://oauth2:${GITLAB_TOKEN}@gitlab.nuclearlighters.net/products/cubeos/releases.git /tmp/releases-repo
      cp CHANGELOG.md /tmp/releases-repo/CHANGELOG.md
      cd /tmp/releases-repo
      git config user.email "ci@cubeos.app"
      git config user.name "CubeOS CI"
      git add CHANGELOG.md
      git diff --staged --quiet || git commit -m "docs: update changelog for v${CUBEOS_VERSION}"
      git push origin main || echo "WARN: Could not push to releases repo (may conflict with current pipeline)"
      cd -

      # Push updated changelog to website repo
      echo "Pushing changelog to website repo..."
      git clone --depth 1 https://oauth2:${GITLAB_TOKEN}@gitlab.nuclearlighters.net/products/cubeos/website.git /tmp/website-changelog
      mkdir -p /tmp/website-changelog/content/changelog

      # Build Hugo content file with frontmatter
      {
        echo '---'
        echo 'title: "Changelog"'
        echo 'description: "Release notes for all CubeOS versions."'
        echo '---'
        echo ''
        tail -n +2 CHANGELOG.md
      } > /tmp/website-changelog/content/changelog/_index.md

      cd /tmp/website-changelog
      git config user.email "ci@cubeos.app"
      git config user.name "CubeOS CI"
      git add content/changelog/_index.md
      git diff --staged --quiet || git commit -m "docs: update changelog for v${CUBEOS_VERSION}"
      git push origin main || echo "WARN: Could not push to website repo (may conflict)"
      cd -

      echo "============================================================"
      echo "  Changelog generation complete"
      echo "  Entry: $(wc -l < changelog-entry.md) lines"
      echo "  Full:  $(wc -l < CHANGELOG.md) lines"
      echo "============================================================"
  artifacts:
    paths:
      - changelog-entry.md
      - CHANGELOG.md
    expire_in: 7 days
  allow_failure: true

# =============================================================================
# Update Website Download Links (every push to main)
# =============================================================================
update-website-links:
  stage: upload
  image: alpine:latest
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
  needs:
    - job: upload-to-dmz
      artifacts: true
      optional: true
    - job: generate-changelog
      artifacts: false
      optional: true
  script:
    - apk add --no-cache git curl
    - |
      set -e

      if [ -z "$GITLAB_TOKEN" ]; then
        echo "ERROR: GITLAB_TOKEN not set"
        exit 1
      fi
      TOKEN="$GITLAB_TOKEN"

      echo "============================================================"
      echo "  Update website download links to ${CUBEOS_VERSION}"
      echo "============================================================"

      # Compute URLs from CUBEOS_VERSION directly so this job does not
      # depend on upload-to-dmz's dotenv artifact for correctness.
      FULL_FILENAME="cubeos-${CUBEOS_VERSION}-arm64.img.xz"
      LITE_FILENAME="cubeos-${CUBEOS_VERSION}-lite-arm64.img.xz"
      FULL_URL="https://releases.cubeos.app/${CUBEOS_VERSION}/${FULL_FILENAME}"
      LITE_URL="https://releases.cubeos.app/${CUBEOS_VERSION}/${LITE_FILENAME}"

      echo "  Full: ${FULL_URL}"
      echo "  Lite: ${LITE_URL}"

      git clone --depth 1 https://oauth2:${TOKEN}@gitlab.nuclearlighters.net/products/cubeos/website.git /tmp/website
      cd /tmp/website

      # Write release metadata that website templates can read
      mkdir -p static
      cat > static/latest-release.json << EOF
      {
        "version": "${CUBEOS_VERSION}",
        "full_url": "${FULL_URL}",
        "lite_url": "${LITE_URL}",
        "full_filename": "${FULL_FILENAME}",
        "lite_filename": "${LITE_FILENAME}",
        "released_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
      }
      EOF

      git config user.email "ci@cubeos.app"
      git config user.name "CubeOS CI"
      git add static/latest-release.json
      git diff --staged --quiet || git commit -m "chore: update download links to ${CUBEOS_VERSION}"
      git push origin main
      echo "  Website repo updated."
  allow_failure: true

# =============================================================================
# Create GitLab Release (tag push only — uses pre-built image from Package Registry)
# =============================================================================
create-gitlab-release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v/'
  variables:
    FULL_IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-arm64"
    LITE_IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-lite-arm64"
  script:
    - |
      echo "Creating GitLab release for ${CI_COMMIT_TAG}..."

      # Download checksums from Package Registry (uploaded during build-image)
      echo "Fetching checksums from Package Registry..."
      apk add --no-cache curl 2>/dev/null || true

      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           -o ${FULL_IMAGE_NAME}.img.xz.sha256 \
           --connect-timeout 30 \
           --retry 3 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${FULL_IMAGE_NAME}.img.xz.sha256"

      curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           -o ${LITE_IMAGE_NAME}.img.xz.sha256 \
           --connect-timeout 30 \
           --retry 3 \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${LITE_IMAGE_NAME}.img.xz.sha256"

      FULL_CHECKSUM=$(cut -d' ' -f1 ${FULL_IMAGE_NAME}.img.xz.sha256)
      LITE_CHECKSUM=$(cut -d' ' -f1 ${LITE_IMAGE_NAME}.img.xz.sha256)
      echo "Full SHA256: ${FULL_CHECKSUM}"
      echo "Lite SHA256: ${LITE_CHECKSUM}"

      if [ -z "$FULL_CHECKSUM" ] || [ -z "$LITE_CHECKSUM" ]; then
        echo "ERROR: Image(s) not found in Package Registry."
        echo "Did you push to main first? build-image must succeed before tagging."
        exit 1
      fi
  release:
    tag_name: "${CI_COMMIT_TAG}"
    name: "CubeOS ${CI_COMMIT_TAG}"
    description: |
      ## CubeOS ${CI_COMMIT_TAG}

      Flashable ARM64 images for Raspberry Pi 4/5 (Ubuntu 24.04.3 based).

      ### Variants
      - **Full**: All services + offline content (4GB+ RAM recommended)
      - **Lite**: Core platform only, install apps from App Store (2GB+ RAM)

      ### Quick Start
      1. Flash the .img.xz to SD card using Raspberry Pi Imager
      2. Boot the Pi
      3. Connect to WiFi AP (check console output for SSID and password)
      4. Open http://cubeos.cube in your browser
      5. Complete the setup wizard

      ### Default Credentials
      - Dashboard: admin / cubeos
      - SSH: cubeos / cubeos (or key-based if configured in Imager)
    assets:
      links:
        - name: "cubeos-${CUBEOS_VERSION}-arm64.img.xz (Full)"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/cubeos-${CUBEOS_VERSION}-arm64.img.xz"
        - name: "cubeos-${CUBEOS_VERSION}-lite-arm64.img.xz (Lite)"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/cubeos-${CUBEOS_VERSION}-lite-arm64.img.xz"
        - name: "Full SHA256 Checksum"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/cubeos-${CUBEOS_VERSION}-arm64.img.xz.sha256"
        - name: "Lite SHA256 Checksum"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/cubeos-${CUBEOS_VERSION}-lite-arm64.img.xz.sha256"

# =============================================================================
# Create GitHub Release (mirror — tag push only, with binary upload)
# =============================================================================
# Uploads both Full and Lite images + Pi Imager manifest as release assets.
# =============================================================================
create-github-release:
  stage: release
  image: alpine:latest
  variables:
    FULL_IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-arm64"
    LITE_IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-lite-arm64"
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v/'
  script:
    - |
      set -e
      apk add --no-cache curl jq bash xz

      if [ -z "${GHCR_TOKEN:-}" ]; then
        echo "WARN: GHCR_TOKEN not set — skipping GitHub release."
        exit 0
      fi

      # --- Step 1: Download both images + checksums from GitLab Package Registry ---
      echo "============================================================"
      echo "  Step 1: Download from GitLab Package Registry"
      echo "============================================================"

      # Helper: download a file from Package Registry
      download_pkg() {
        local filename="$1"
        echo "Downloading ${filename}..."
        curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
             -o "${filename}" \
             --connect-timeout 30 \
             --max-time 3600 \
             --retry 3 \
             --retry-delay 60 \
             "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${filename}"
      }

      # Download checksums
      download_pkg "${FULL_IMAGE_NAME}.img.xz.sha256"
      download_pkg "${LITE_IMAGE_NAME}.img.xz.sha256"

      FULL_CHECKSUM=$(cut -d' ' -f1 "${FULL_IMAGE_NAME}.img.xz.sha256")
      LITE_CHECKSUM=$(cut -d' ' -f1 "${LITE_IMAGE_NAME}.img.xz.sha256")
      echo "Full SHA256: ${FULL_CHECKSUM}"
      echo "Lite SHA256: ${LITE_CHECKSUM}"

      if [ -z "$FULL_CHECKSUM" ] || [ -z "$LITE_CHECKSUM" ]; then
        echo "ERROR: Image(s) not found in Package Registry."
        exit 1
      fi

      # Download images
      download_pkg "${FULL_IMAGE_NAME}.img.xz"
      download_pkg "${LITE_IMAGE_NAME}.img.xz"

      echo "Full: $(du -h ${FULL_IMAGE_NAME}.img.xz | cut -f1)"
      echo "Lite: $(du -h ${LITE_IMAGE_NAME}.img.xz | cut -f1)"

      # Verify checksums
      echo "Verifying checksums..."
      echo "${FULL_CHECKSUM}  ${FULL_IMAGE_NAME}.img.xz" | sha256sum -c -
      echo "${LITE_CHECKSUM}  ${LITE_IMAGE_NAME}.img.xz" | sha256sum -c -

      # --- Step 1b: Generate Pi Imager manifest ---
      echo "============================================================"
      echo "  Step 1b: Generate Pi Imager manifest"
      echo "============================================================"
      # Decompress both images temporarily to calculate Pi Imager checksums
      xz -dk ${FULL_IMAGE_NAME}.img.xz
      xz -dk ${LITE_IMAGE_NAME}.img.xz
      chmod +x scripts/calculate-checksums.sh scripts/update-manifest.sh
      bash scripts/update-manifest.sh "${CUBEOS_VERSION}"
      rm -f ${FULL_IMAGE_NAME}.img ${LITE_IMAGE_NAME}.img
      echo "Manifest generated:"
      cat imager/rpi-imager.json

      # --- Step 2: Create GitHub Release ---
      echo "============================================================"
      echo "  Step 2: Create GitHub Release"
      echo "============================================================"

      FULL_SIZE=$(du -h ${FULL_IMAGE_NAME}.img.xz | cut -f1)
      LITE_SIZE=$(du -h ${LITE_IMAGE_NAME}.img.xz | cut -f1)
      FULL_URL="https://releases.cubeos.app/${CUBEOS_VERSION}/${FULL_IMAGE_NAME}.img.xz"
      LITE_URL="https://releases.cubeos.app/${CUBEOS_VERSION}/${LITE_IMAGE_NAME}.img.xz"
      CHECKSUMS_URL="https://releases.cubeos.app/${CUBEOS_VERSION}/checksums.sha256"

      RELEASE_BODY="## CubeOS ${CI_COMMIT_TAG}

      Flashable ARM64 image for Raspberry Pi 4/5 (Ubuntu 24.04 based).

      ### Download

      | File | Link | Size |
      |------|------|------|
      | Full image (all services) | [${FULL_IMAGE_NAME}.img.xz](${FULL_URL}) | ${FULL_SIZE} |
      | Lite image (minimal) | [${LITE_IMAGE_NAME}.img.xz](${LITE_URL}) | ${LITE_SIZE} |
      | SHA256 checksums | [checksums.sha256](${CHECKSUMS_URL}) | |

      ### Quick Start

      1. Download the Full image above
      2. Flash to SD card using [Raspberry Pi Imager](https://www.raspberrypi.com/software/) — Use custom image
      3. Boot the Pi — connect to the **CubeOS** WiFi AP (password: cubeos123)
      4. Open **http://cubeos.cube** and complete the setup wizard

      ### Install on x86/ARM64 Linux

      \`\`\`bash
      curl -fsSL https://get.cubeos.app | sudo bash
      \`\`\`

      ### Pi Imager

      Add CubeOS to Raspberry Pi Imager with this custom repository URL:
      \`\`\`
      https://github.com/${GITHUB_REPO}/releases/download/${CI_COMMIT_TAG}/rpi-imager.json
      \`\`\`

      ### Default Credentials

      - **SSH:** cubeos / cubeos
      - **Dashboard:** admin / cubeos
      - **WiFi AP:** CubeOS-{serial} / cubeos123

      ### What's New
      "

      # Fetch changelog entry for this version from releases repo
      CHANGELOG_RAW=$(curl -sf --header "PRIVATE-TOKEN: ${GITLAB_TOKEN:-}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/repository/files/CHANGELOG.md/raw?ref=main" 2>/dev/null || echo "")
      if [ -n "$CHANGELOG_RAW" ]; then
        # Extract the section for current version (between ## vX.Y.Z and next ## or ---)
        VERSION_SECTION=$(echo "$CHANGELOG_RAW" | sed -n "/^## ${CI_COMMIT_TAG} /,/^---$/p" | head -n -1 | tail -n +2)
        if [ -n "$VERSION_SECTION" ]; then
          RELEASE_BODY="${RELEASE_BODY}
      ${VERSION_SECTION}

      Full changelog: [get.cubeos.app/changelog](https://get.cubeos.app/changelog/)"
        else
          RELEASE_BODY="${RELEASE_BODY}
      See [CHANGELOG](https://get.cubeos.app/changelog/) for details."
        fi
      else
        RELEASE_BODY="${RELEASE_BODY}
      See [CHANGELOG](https://get.cubeos.app/changelog/) for details."
      fi

      echo "Creating GitHub release for ${CI_COMMIT_TAG} on ${GITHUB_REPO}..."
      RESPONSE=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: token ${GHCR_TOKEN}" \
        -H "Accept: application/vnd.github+json" \
        "https://api.github.com/repos/${GITHUB_REPO}/releases" \
        -d "$(jq -n \
          --arg tag "${CI_COMMIT_TAG}" \
          --arg name "CubeOS ${CI_COMMIT_TAG}" \
          --arg body "${RELEASE_BODY}" \
          '{tag_name: $tag, name: $name, body: $body, draft: false, prerelease: true}'
        )")

      HTTP_CODE=$(echo "$RESPONSE" | tail -1)
      RESP_BODY=$(echo "$RESPONSE" | sed '$d')
      echo "GitHub API: HTTP ${HTTP_CODE}"

      if [ "$HTTP_CODE" = "201" ]; then
        RELEASE_ID=$(echo "$RESP_BODY" | jq -r '.id')
        UPLOAD_URL=$(echo "$RESP_BODY" | jq -r '.upload_url' | sed 's/{?name,label}//')
        echo "  Release created (ID: ${RELEASE_ID})"
      elif [ "$HTTP_CODE" = "422" ]; then
        echo "  Release already exists — fetching existing release..."
        EXISTING=$(curl -s \
          -H "Authorization: token ${GHCR_TOKEN}" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${GITHUB_REPO}/releases/tags/${CI_COMMIT_TAG}")
        RELEASE_ID=$(echo "$EXISTING" | jq -r '.id')
        UPLOAD_URL=$(echo "$EXISTING" | jq -r '.upload_url' | sed 's/{?name,label}//')

        curl -s -X PATCH \
          -H "Authorization: token ${GHCR_TOKEN}" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${GITHUB_REPO}/releases/${RELEASE_ID}" \
          -d "$(jq -n \
            --arg body "${RELEASE_BODY}" \
            '{body: $body}'
          )" > /dev/null

        # Delete existing assets (re-upload fresh)
        echo "  Deleting old assets..."
        ASSETS=$(curl -s \
          -H "Authorization: token ${GHCR_TOKEN}" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${GITHUB_REPO}/releases/${RELEASE_ID}/assets")
        echo "$ASSETS" | jq -r '.[].id' | while read ASSET_ID; do
          curl -s -X DELETE \
            -H "Authorization: token ${GHCR_TOKEN}" \
            "https://api.github.com/repos/${GITHUB_REPO}/releases/assets/${ASSET_ID}" || true
        done
        echo "  Updated existing release (ID: ${RELEASE_ID})"
      else
        echo "  ERROR: Unexpected response."
        echo "$RESP_BODY" | jq . 2>/dev/null || echo "$RESP_BODY"
        exit 1
      fi

      # --- Step 3: Upload all assets ---
      echo "============================================================"
      echo "  Step 3: Upload assets to GitHub Release"
      echo "============================================================"

      upload_asset() {
        local filename="$1" content_type="$2"
        echo "Uploading ${filename} ($(du -h ${filename} | cut -f1))..."
        local RESP CODE
        RESP=$(curl -s -w "\n%{http_code}" \
          --max-time 3600 \
          -X POST \
          -H "Authorization: token ${GHCR_TOKEN}" \
          -H "Content-Type: ${content_type}" \
          "${UPLOAD_URL}?name=${filename}" \
          --data-binary "@${filename}")
        CODE=$(echo "$RESP" | tail -1)
        if [ "$CODE" = "201" ]; then
          echo "  OK: ${filename}"
        else
          echo "  WARN: ${filename} upload failed (HTTP ${CODE})"
        fi
      }

      # Full image + checksum
      upload_asset "${FULL_IMAGE_NAME}.img.xz" "application/x-xz"
      upload_asset "${FULL_IMAGE_NAME}.img.xz.sha256" "text/plain"

      # Lite image + checksum
      upload_asset "${LITE_IMAGE_NAME}.img.xz" "application/x-xz"
      upload_asset "${LITE_IMAGE_NAME}.img.xz.sha256" "text/plain"

      # Pi Imager manifest
      upload_asset "imager/rpi-imager.json" "application/json"

      echo "============================================================"
      echo "  GitHub Release complete!"
      echo "  https://github.com/${GITHUB_REPO}/releases/tag/${CI_COMMIT_TAG}"
      echo "  Pi Imager URL: https://github.com/${GITHUB_REPO}/releases/download/${CI_COMMIT_TAG}/rpi-imager.json"
      echo "============================================================"
  allow_failure: true
  timeout: 120m

# =============================================================================
# Upload to Releases Server (tag push only — after GitLab/GitHub releases)
# =============================================================================
# Downloads built images from Package Registry and uploads them to the DMZ
# releases server via SCP. Also updates channel metadata on the website.
#
# Required CI variables (group-level):
#   CI_DEPLOY_SSH_KEY     — SSH private key for DMZ access
# Required CI variables (project-level):
#   RELEASES_DEPLOY_HOST  — DMZ hostname for releases (e.g., nllei01dmz01)
#   WEBSITE_DEPLOY_HOST   — DMZ hostname for website (e.g., nllei01dmz01)
# =============================================================================
upload-releases:
  stage: deploy
  tags: [multiarch]
  image: alpine:latest
  variables:
    FULL_IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-arm64"
    LITE_IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-lite-arm64"
  before_script:
    - apk add --no-cache openssh-client curl jq bash xz
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - echo "$CI_DEPLOY_SSH_KEY" > ~/.ssh/id_ed25519 && chmod 600 ~/.ssh/id_ed25519
    - ssh-keyscan -H "$RELEASES_DEPLOY_HOST" >> ~/.ssh/known_hosts 2>/dev/null
    - |
      if [ "$WEBSITE_DEPLOY_HOST" != "$RELEASES_DEPLOY_HOST" ]; then
        ssh-keyscan -H "$WEBSITE_DEPLOY_HOST" >> ~/.ssh/known_hosts 2>/dev/null
      fi
  script:
    - |
      set -e
      export CUBEOS_VERSION="${CI_COMMIT_TAG#v}"
      echo "============================================================"
      echo "  Uploading CubeOS ${CUBEOS_VERSION} to releases server"
      echo "============================================================"

      # Download images from GitLab Package Registry
      download_pkg() {
        local filename="$1"
        echo "Downloading ${filename} from Package Registry..."
        curl --fail --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
             -o "${filename}" \
             --connect-timeout 30 \
             --max-time 3600 \
             --retry 3 \
             --retry-delay 60 \
             "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${filename}"
      }

      download_pkg "${FULL_IMAGE_NAME}.img.xz"
      download_pkg "${FULL_IMAGE_NAME}.img.xz.sha256"
      download_pkg "${LITE_IMAGE_NAME}.img.xz"
      download_pkg "${LITE_IMAGE_NAME}.img.xz.sha256"

      # Verify checksums before upload
      echo "Verifying checksums..."
      sha256sum -c "${FULL_IMAGE_NAME}.img.xz.sha256"
      sha256sum -c "${LITE_IMAGE_NAME}.img.xz.sha256"

      # Generate Pi Imager manifest (needs decompressed images)
      xz -dk "${FULL_IMAGE_NAME}.img.xz"
      xz -dk "${LITE_IMAGE_NAME}.img.xz"
      chmod +x scripts/calculate-checksums.sh scripts/update-manifest.sh
      bash scripts/update-manifest.sh "${CUBEOS_VERSION}"
      rm -f "${FULL_IMAGE_NAME}.img" "${LITE_IMAGE_NAME}.img"

      # Run upload script
      bash scripts/upload-to-releases-server.sh

      # Run channel update script
      bash scripts/update-channels.sh
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+/'
  needs:
    - job: create-gitlab-release
      optional: true
    - job: create-github-release
      optional: true
  environment:
    name: releases
    url: https://releases.cubeos.app
  timeout: 60m

# =============================================================================
# Sync install.sh to Website Repo
# =============================================================================
# Automatically copies releases/curl/install.sh → website/static/install.sh
# on every push to main. The website CI then picks up the push and redeploys
# get.cubeos.app automatically. No-op when install.sh hasn't changed.
# =============================================================================
sync-installer:
  stage: publish
  image: alpine:latest
  needs: []  # Run immediately — no dependency on build/validate/release stages
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v/'
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - curl/install.sh
  script:
    - apk add --no-cache git
    - |
      if [ -z "$GITLAB_TOKEN" ]; then
        echo "ERROR: GITLAB_TOKEN not set"
        exit 1
      fi
      TOKEN="$GITLAB_TOKEN"
      git clone https://oauth2:${TOKEN}@gitlab.nuclearlighters.net/products/cubeos/website.git /tmp/website
      cp curl/install.sh /tmp/website/static/install.sh
      cd /tmp/website
      git config user.email "ci@cubeos.app"
      git config user.name "CubeOS CI"
      git add static/install.sh
      # Only commit if there are changes
      git diff --staged --quiet || git commit -m "chore: sync install.sh from releases $(git -C $CI_PROJECT_DIR rev-parse --short HEAD)"
      git push origin main
  allow_failure: true

# =============================================================================
# Tag all repos — creates version tags across all 10 CubeOS GitLab projects.
# Tags mirror to GitHub automatically via existing GitLab mirror configuration.
# =============================================================================
tag-all-repos:
  stage: tag
  image: alpine:latest
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
  needs:
    - job: upload-to-dmz
      artifacts: false
  script:
    - apk add --no-cache curl jq
    - |
      TAG="v${CUBEOS_VERSION}"
      echo "Tagging all repos with ${TAG}"

      for PROJECT_ID in 13 14 16 19 20 22 23 24 25 26; do
        SHA=$(curl -sf --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
          "https://gitlab.nuclearlighters.net/api/v4/projects/${PROJECT_ID}/repository/branches/main" \
          | jq -r '.commit.id')

        if [ -z "$SHA" ] || [ "$SHA" = "null" ]; then
          echo "WARNING: Could not get SHA for project ${PROJECT_ID}, skipping"
          continue
        fi

        # Skip if tag already exists
        EXISTS=$(curl -s --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
          "https://gitlab.nuclearlighters.net/api/v4/projects/${PROJECT_ID}/repository/tags/${TAG}" \
          | jq -r '.name // empty')
        if [ -n "$EXISTS" ]; then
          echo "  project ${PROJECT_ID}: ${TAG} already exists, skipping"
          continue
        fi

        RESULT=$(curl -sf -X POST \
          --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
          --header "Content-Type: application/json" \
          "https://gitlab.nuclearlighters.net/api/v4/projects/${PROJECT_ID}/repository/tags" \
          -d "{\"tag_name\": \"${TAG}\", \"ref\": \"${SHA}\", \"message\": \"CubeOS ${TAG} release\"}" \
          | jq -r '.name // empty')

        if [ -n "$RESULT" ]; then
          echo "  project ${PROJECT_ID} tagged at ${SHA:0:8}"
        else
          echo "  ERROR: Failed to tag project ${PROJECT_ID}"
          exit 1
        fi
      done

      echo "All 10 repos tagged with ${TAG} — will mirror to GitHub automatically"
