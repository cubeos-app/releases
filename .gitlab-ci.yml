# =============================================================================
# CubeOS Release Image Pipeline
# =============================================================================
# Builds a flashable ARM64 SD card image for Raspberry Pi 4/5.
#
# Stages:
#   1. download — Fetch ARM64 Docker images via skopeo (native x86 speed)
#   2. build    — Packer builds the image under QEMU ARM64 emulation
#   3. compress — PiShrink + zerofree + xz compression + checksums
#
# Required CI variables (set at group/project level):
#   - GHCR_USER  — GitHub username for GHCR (same as api/hal/dashboard pipelines)
#   - GHCR_TOKEN — GitHub PAT with read:packages scope
#
# Runner requirements:
#   - Self-hosted runner with privileged Docker executor
#   - volumes: ["/var/run/docker.sock:/var/run/docker.sock", "/dev:/dev"]
#   - qemu-user-static registered on host (binfmt_misc)
# =============================================================================

stages:
  - download
  - build
  - compress

variables:
  CUBEOS_VERSION: "0.1.0-alpha"
  IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-arm64"
  BASE_IMAGE_URL: "https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz"
  BASE_IMAGE_CHECKSUM_URL: "https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz.sha256"

# =============================================================================
# Stage 1: Download ARM64 Docker images at native x86 speed
# =============================================================================
# Skopeo pulls ARM64 manifests natively on x86 — no QEMU emulation needed.
# Images are saved as docker-archive tarballs, passed to Stage 2 as artifacts.
#
# GHCR image names (must match what api/hal/dashboard pipelines push):
#   ghcr.io/cubeos-app/api        (NOT cubeos-api)
#   ghcr.io/cubeos-app/hal        (NOT cubeos-hal)
#   ghcr.io/cubeos-app/dashboard  (NOT cubeos-dashboard)
# =============================================================================
download-docker-images:
  stage: download
  image:
    name: quay.io/skopeo/stable:latest
    entrypoint: [""]
  before_script:
    # Verify GHCR credentials are available (fail fast)
    - |
      if [ -z "${GHCR_USER}" ] || [ -z "${GHCR_TOKEN}" ]; then
        echo "ERROR: GHCR_USER and GHCR_TOKEN CI variables are required."
        echo "Set them at group level: GitLab → cubeos group → Settings → CI/CD → Variables"
        exit 1
      fi
      echo "GHCR auth: ${GHCR_USER}"
  script:
    - mkdir -p docker-images
    - echo "=== Downloading ARM64 Docker images ==="

    # Public images (Docker Hub — no auth needed)
    - echo "[1/5] Pi-hole..."
    - skopeo copy --override-arch arm64 --override-os linux --retry-times 3 docker://docker.io/pihole/pihole:latest docker-archive:docker-images/pihole.tar:pihole/pihole:latest

    - echo "[2/5] Nginx Proxy Manager..."
    - skopeo copy --override-arch arm64 --override-os linux --retry-times 3 docker://docker.io/jc21/nginx-proxy-manager:latest docker-archive:docker-images/npm.tar:jc21/nginx-proxy-manager:latest

    # Private images (GHCR — auth via --src-creds using GitLab CI variables)
    - echo "[3/5] CubeOS API..."
    - skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" --override-arch arm64 --override-os linux --retry-times 3 docker://ghcr.io/cubeos-app/api:latest docker-archive:docker-images/cubeos-api.tar:ghcr.io/cubeos-app/api:latest

    - echo "[4/5] CubeOS HAL..."
    - skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" --override-arch arm64 --override-os linux --retry-times 3 docker://ghcr.io/cubeos-app/hal:latest docker-archive:docker-images/cubeos-hal.tar:ghcr.io/cubeos-app/hal:latest

    - echo "[5/5] CubeOS Dashboard..."
    - skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" --override-arch arm64 --override-os linux --retry-times 3 docker://ghcr.io/cubeos-app/dashboard:latest docker-archive:docker-images/cubeos-dashboard.tar:ghcr.io/cubeos-app/dashboard:latest

    # Summary
    - echo ""
    - echo "=== Download complete ==="
    - ls -lh docker-images/
    - du -sh docker-images/
  artifacts:
    paths:
      - docker-images/
    expire_in: 4 hours

# =============================================================================
# Stage 2: Build image with Packer under QEMU emulation
# =============================================================================
# packer-builder-arm loop-mounts the base Pi OS image, chroots with QEMU
# user-mode emulation, and runs our provisioning scripts inside the chroot.
#
# QEMU binfmt must be registered on the HOST (done once, persists across
# reboots). The runner's privileged mode gives access to /dev/loop*.
# =============================================================================
build-image:
  stage: build
  image:
    name: mkaczanowski/packer-builder-arm:latest
    entrypoint: [""]
  needs:
    - download-docker-images
  before_script:
    # Mount host kernel's binfmt_misc inside this privileged container.
    # The host has QEMU registered (via multiarch/qemu-user-static with F flag),
    # but containers get a fresh /proc where binfmt_misc isn't auto-mounted.
    # This mount exposes the host kernel's registrations (binfmt_misc is non-namespaced).
    - mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc || true
    - |
      if [ ! -f /proc/sys/fs/binfmt_misc/qemu-aarch64 ]; then
        echo "ERROR: QEMU aarch64 binfmt not registered on host!"
        echo "Fix: ssh to runner host and run:"
        echo "  docker run --rm --privileged multiarch/qemu-user-static --reset -p yes"
        exit 1
      fi
      echo "QEMU aarch64 binfmt: OK"
  script:
    - echo "=== Building CubeOS ${CUBEOS_VERSION} image ==="
    - echo "Base image  ${BASE_IMAGE_URL}"
    - echo "Output      ${IMAGE_NAME}.img"

    # Ensure scripts are executable
    - chmod +x packer/scripts/*.sh firstboot/*.sh

    # Build the image
    - packer build -var "version=${CUBEOS_VERSION}" -var "base_image_url=${BASE_IMAGE_URL}" -var "base_image_checksum=${BASE_IMAGE_CHECKSUM_URL}" packer/cubeos.pkr.hcl

    # Verify output
    - ls -lh ${IMAGE_NAME}.img
    - echo "=== Image built successfully ==="
  artifacts:
    paths:
      - "${IMAGE_NAME}.img"
    expire_in: 4 hours
  timeout: 45m

# =============================================================================
# Stage 3: Shrink, zero, compress, checksum
# =============================================================================
compress-image:
  stage: compress
  image: ubuntu:24.04
  needs:
    - build-image
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq xz-utils e2fsprogs zerofree parted wget kpartx util-linux
  script:
    - echo "=== Compressing ${IMAGE_NAME}.img ==="
    - ls -lh ${IMAGE_NAME}.img

    # ── Step 1: PiShrink — shrink partition, add auto-expand on first boot ──
    - echo "[1/4] Running PiShrink..."
    - wget -q -O pishrink.sh https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh || echo "WARN PiShrink download failed, skipping shrink"
    - |
      if [ -f pishrink.sh ]; then
        chmod +x pishrink.sh
        bash pishrink.sh -s ${IMAGE_NAME}.img || echo "WARN PiShrink failed (non-fatal), continuing with unshrunk image"
      fi

    # ── Step 2: Zerofree — zero unused blocks for better xz compression ─────
    - echo "[2/4] Running zerofree..."
    - |
      LOOPDEV=""
      cleanup_loop() {
        if [ -n "$LOOPDEV" ]; then
          echo "Cleaning up loop device $LOOPDEV"
          losetup -d "$LOOPDEV" 2>/dev/null || true
        fi
      }
      trap cleanup_loop EXIT

      LOOPDEV=$(losetup -fP --show ${IMAGE_NAME}.img)
      echo "Loop device: $LOOPDEV"

      # Wait for partition devices to appear
      sleep 2
      ls -la ${LOOPDEV}p* 2>/dev/null || echo "No partition devices found"

      ROOT_PART="${LOOPDEV}p2"
      if [ -b "$ROOT_PART" ]; then
        echo "Running e2fsck on $ROOT_PART..."
        e2fsck -fy "$ROOT_PART" || true
        echo "Running zerofree on $ROOT_PART..."
        zerofree -v "$ROOT_PART" || echo "WARN zerofree failed (non-fatal)"
      else
        echo "WARN Root partition $ROOT_PART not found, skipping zerofree"
      fi

      losetup -d "$LOOPDEV"
      LOOPDEV=""

    # ── Step 3: XZ compress ─────────────────────────────────────────────────
    - echo "[3/4] Compressing with xz -6 (multi-threaded)..."
    - xz -6 -T0 -v ${IMAGE_NAME}.img

    # ── Step 4: Checksums ───────────────────────────────────────────────────
    - echo "[4/4] Calculating checksums..."
    - sha256sum ${IMAGE_NAME}.img.xz > ${IMAGE_NAME}.img.xz.sha256
    - md5sum ${IMAGE_NAME}.img.xz > ${IMAGE_NAME}.img.xz.md5

    # ── Summary ─────────────────────────────────────────────────────────────
    - echo ""
    - echo "============================================================"
    - echo "  CubeOS Release Artifact"
    - echo "============================================================"
    - echo "  File     ${IMAGE_NAME}.img.xz"
    - echo "  Size     $(du -h ${IMAGE_NAME}.img.xz | cut -f1)"
    - echo "  SHA256   $(cut -d' ' -f1 ${IMAGE_NAME}.img.xz.sha256)"
    - echo "============================================================"
  artifacts:
    paths:
      - "${IMAGE_NAME}.img.xz"
      - "${IMAGE_NAME}.img.xz.sha256"
      - "${IMAGE_NAME}.img.xz.md5"
    expire_in: 30 days
  timeout: 30m

# =============================================================================
# Optional: Create GitLab Release (triggered by tag push only)
# =============================================================================
create-release:
  stage: .post
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - compress-image
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v/'
  script:
    - echo "Creating release for ${CI_COMMIT_TAG}..."
    - CHECKSUM=$(cut -d' ' -f1 ${IMAGE_NAME}.img.xz.sha256)
    - echo "SHA256 ${CHECKSUM}"
  release:
    tag_name: "${CI_COMMIT_TAG}"
    name: "CubeOS ${CI_COMMIT_TAG}"
    description: |
      ## CubeOS ${CI_COMMIT_TAG}

      Flashable ARM64 image for Raspberry Pi 4/5.

      ### Quick Start
      1. Flash the .img.xz to SD card using Raspberry Pi Imager
      2. Boot the Pi
      3. Connect to WiFi AP (check console output for SSID and password)
      4. Open http://cubeos.cube in your browser
      5. Complete the setup wizard

      ### Default Credentials
      - Dashboard: admin / cubeos
      - SSH: key-only (configure in wizard)
    assets:
      links:
        - name: "${IMAGE_NAME}.img.xz"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz"
        - name: "SHA256 Checksum"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz.sha256"
