# =============================================================================
# CubeOS Release Image Pipeline
# =============================================================================
# Builds a flashable ARM64 SD card image for Raspberry Pi 4/5.
#
# Stages:
#   1. download — Fetch ARM64 Docker images via skopeo (native x86 speed)
#   2. build    — Packer builds the image under QEMU ARM64 emulation,
#                 then shrinks + compresses in the same privileged container
#
# Required CI variables (set at group/project level):
#   - GHCR_USER  — GitHub username for GHCR (same as api/hal/dashboard pipelines)
#   - GHCR_TOKEN — GitHub PAT with read:packages scope
#
# Runner requirements:
#   - Self-hosted runner with privileged Docker executor
#   - volumes: ["/var/run/docker.sock:/var/run/docker.sock", "/dev:/dev"]
#   - qemu-user-static registered on host (binfmt_misc)
# =============================================================================

stages:
  - download
  - build

variables:
  CUBEOS_VERSION: "0.1.0-alpha"
  IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-arm64"
  BASE_IMAGE_URL: "https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz"
  BASE_IMAGE_CHECKSUM_URL: "https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz.sha256"

# =============================================================================
# Stage 1: Download ARM64 Docker images at native x86 speed
# =============================================================================
# Skopeo pulls ARM64 manifests natively on x86 — no QEMU emulation needed.
# Images are saved as docker-archive tarballs, passed to Stage 2 as artifacts.
#
# GHCR image names (must match what api/hal/dashboard pipelines push):
#   ghcr.io/cubeos-app/api        (NOT cubeos-api)
#   ghcr.io/cubeos-app/hal        (NOT cubeos-hal)
#   ghcr.io/cubeos-app/dashboard  (NOT cubeos-dashboard)
# =============================================================================
download-docker-images:
  stage: download
  image:
    name: quay.io/skopeo/stable:latest
    entrypoint: [""]
  before_script:
    # Verify GHCR credentials are available (fail fast)
    - |
      if [ -z "${GHCR_USER}" ] || [ -z "${GHCR_TOKEN}" ]; then
        echo "ERROR: GHCR_USER and GHCR_TOKEN CI variables are required."
        echo "Set them at group level: GitLab → cubeos group → Settings → CI/CD → Variables"
        exit 1
      fi
      echo "GHCR auth: ${GHCR_USER}"
  script:
    - mkdir -p docker-images
    - echo "=== Downloading ARM64 Docker images ==="

    # Public images (Docker Hub — no auth needed)
    - echo "[1/5] Pi-hole..."
    - skopeo copy --override-arch arm64 --override-os linux --retry-times 3 docker://docker.io/pihole/pihole:latest docker-archive:docker-images/pihole.tar:pihole/pihole:latest

    - echo "[2/5] Nginx Proxy Manager..."
    - skopeo copy --override-arch arm64 --override-os linux --retry-times 3 docker://docker.io/jc21/nginx-proxy-manager:latest docker-archive:docker-images/npm.tar:jc21/nginx-proxy-manager:latest

    # Private images (GHCR — auth via --src-creds using GitLab CI variables)
    - echo "[3/5] CubeOS API..."
    - skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" --override-arch arm64 --override-os linux --retry-times 3 docker://ghcr.io/cubeos-app/api:latest docker-archive:docker-images/cubeos-api.tar:ghcr.io/cubeos-app/api:latest

    - echo "[4/5] CubeOS HAL..."
    - skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" --override-arch arm64 --override-os linux --retry-times 3 docker://ghcr.io/cubeos-app/hal:latest docker-archive:docker-images/cubeos-hal.tar:ghcr.io/cubeos-app/hal:latest

    - echo "[5/5] CubeOS Dashboard..."
    - skopeo copy --src-creds "${GHCR_USER}:${GHCR_TOKEN}" --override-arch arm64 --override-os linux --retry-times 3 docker://ghcr.io/cubeos-app/dashboard:latest docker-archive:docker-images/cubeos-dashboard.tar:ghcr.io/cubeos-app/dashboard:latest

    # Summary
    - echo ""
    - echo "=== Download complete ==="
    - ls -lh docker-images/
    - du -sh docker-images/
  artifacts:
    paths:
      - docker-images/
    expire_in: 4 hours

# =============================================================================
# Stage 2: Build image with Packer, then shrink + compress
# =============================================================================
# Both Packer and the compress step need privileged access to loop devices,
# so they run in the same container. This also avoids uploading the raw 8GB
# image as a GitLab artifact between stages (which exceeds the upload limit).
#
# Steps:
#   1. Packer builds the 8GB raw image under QEMU ARM64 emulation
#   2. PiShrink shrinks the partition and adds auto-expand on first boot
#   3. Zerofree zeros unused blocks for better compression
#   4. xz compresses the image (~8GB raw → ~1.5-2GB compressed)
#   5. SHA256 + MD5 checksums
# =============================================================================
build-image:
  stage: build
  image:
    name: mkaczanowski/packer-builder-arm:latest
    entrypoint: [""]
  needs:
    - download-docker-images
  before_script:
    # Mount host kernel's binfmt_misc inside this privileged container.
    - mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc || true
    - |
      if [ ! -f /proc/sys/fs/binfmt_misc/qemu-aarch64 ]; then
        echo "ERROR: QEMU aarch64 binfmt not registered on host!"
        echo "Fix: ssh to runner host and run:"
        echo "  docker run --rm --privileged multiarch/qemu-user-static --reset -p yes"
        exit 1
      fi
      echo "QEMU aarch64 binfmt: OK"

    # Install compression tools needed for post-build processing.
    # The packer-builder-arm image is Ubuntu-based but doesn't include these.
    - echo "Installing compression tools..."
    - apt-get update -qq
    - apt-get install -y -qq xz-utils zerofree e2fsprogs parted wget kpartx util-linux 2>&1 | tail -1
    - echo "Compression tools installed."
  script:
    # =====================================================================
    # Phase 1: Packer build
    # =====================================================================
    - echo "=== Building CubeOS ${CUBEOS_VERSION} image ==="
    - echo "Base image  ${BASE_IMAGE_URL}"
    - echo "Output      ${IMAGE_NAME}.img"

    # Ensure scripts are executable
    - chmod +x packer/scripts/*.sh firstboot/*.sh

    # Build the image
    - packer build -var "version=${CUBEOS_VERSION}" -var "base_image_url=${BASE_IMAGE_URL}" -var "base_image_checksum=${BASE_IMAGE_CHECKSUM_URL}" packer/cubeos.pkr.hcl

    # Verify output
    - ls -lh ${IMAGE_NAME}.img
    - echo "=== Packer build complete ==="
    - echo ""

    # =====================================================================
    # Phase 2: Shrink + Compress
    # =====================================================================
    - echo "=== Compressing ${IMAGE_NAME}.img ==="

    # ── Step 1: PiShrink — shrink partition, add auto-expand on first boot ──
    - echo "[1/4] Running PiShrink..."
    - wget -q -O pishrink.sh https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh || echo "WARN PiShrink download failed, skipping shrink"
    - |
      if [ -f pishrink.sh ]; then
        chmod +x pishrink.sh
        bash pishrink.sh -s ${IMAGE_NAME}.img || echo "WARN PiShrink failed (non-fatal), continuing with unshrunk image"
      fi

    # ── Step 2: Zerofree — zero unused blocks for better xz compression ─────
    - echo "[2/4] Running zerofree..."
    - |
      LOOPDEV=""
      cleanup_loop() {
        if [ -n "$LOOPDEV" ]; then
          echo "Cleaning up loop device $LOOPDEV"
          losetup -d "$LOOPDEV" 2>/dev/null || true
        fi
      }
      trap cleanup_loop EXIT

      LOOPDEV=$(losetup -fP --show ${IMAGE_NAME}.img)
      echo "Loop device: $LOOPDEV"

      # Wait for partition devices to appear
      sleep 2
      ls -la ${LOOPDEV}p* 2>/dev/null || echo "No partition devices found"

      ROOT_PART="${LOOPDEV}p2"
      if [ -b "$ROOT_PART" ]; then
        echo "Running e2fsck on $ROOT_PART..."
        e2fsck -fy "$ROOT_PART" || true
        echo "Running zerofree on $ROOT_PART..."
        zerofree -v "$ROOT_PART" || echo "WARN zerofree failed (non-fatal)"
      else
        echo "WARN Root partition $ROOT_PART not found, skipping zerofree"
      fi

      losetup -d "$LOOPDEV"
      LOOPDEV=""

    # ── Step 3: XZ compress ─────────────────────────────────────────────────
    - echo "[3/4] Compressing with xz -6 (multi-threaded)..."
    - ls -lh ${IMAGE_NAME}.img
    - xz -6 -T0 -v ${IMAGE_NAME}.img

    # ── Step 4: Checksums ───────────────────────────────────────────────────
    - echo "[4/4] Calculating checksums..."
    - sha256sum ${IMAGE_NAME}.img.xz > ${IMAGE_NAME}.img.xz.sha256
    - md5sum ${IMAGE_NAME}.img.xz > ${IMAGE_NAME}.img.xz.md5

    # ── Summary ─────────────────────────────────────────────────────────────
    - echo ""
    - echo "============================================================"
    - echo "  CubeOS Release Artifact"
    - echo "============================================================"
    - echo "  File     ${IMAGE_NAME}.img.xz"
    - echo "  Size     $(du -h ${IMAGE_NAME}.img.xz | cut -f1)"
    - echo "  SHA256   $(cut -d' ' -f1 ${IMAGE_NAME}.img.xz.sha256)"
    - echo "============================================================"
  artifacts:
    paths:
      - "${IMAGE_NAME}.img.xz"
      - "${IMAGE_NAME}.img.xz.sha256"
      - "${IMAGE_NAME}.img.xz.md5"
    expire_in: 30 days
  timeout: 60m

# =============================================================================
# Optional: Create GitLab Release (triggered by tag push only)
# =============================================================================
create-release:
  stage: .post
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - build-image
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v/'
  script:
    - echo "Creating release for ${CI_COMMIT_TAG}..."
    - CHECKSUM=$(cut -d' ' -f1 ${IMAGE_NAME}.img.xz.sha256)
    - echo "SHA256 ${CHECKSUM}"
  release:
    tag_name: "${CI_COMMIT_TAG}"
    name: "CubeOS ${CI_COMMIT_TAG}"
    description: |
      ## CubeOS ${CI_COMMIT_TAG}

      Flashable ARM64 image for Raspberry Pi 4/5.

      ### Quick Start
      1. Flash the .img.xz to SD card using Raspberry Pi Imager
      2. Boot the Pi
      3. Connect to WiFi AP (check console output for SSID and password)
      4. Open http://cubeos.cube in your browser
      5. Complete the setup wizard

      ### Default Credentials
      - Dashboard: admin / cubeos
      - SSH: key-only (configure in wizard)
    assets:
      links:
        - name: "${IMAGE_NAME}.img.xz"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz"
        - name: "SHA256 Checksum"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz.sha256"
