# =============================================================================
# CubeOS Release Image Pipeline
# =============================================================================
# Builds a flashable ARM64 SD card image for Raspberry Pi 4/5.
#
# Stages:
#   1. download — Fetch ARM64 Docker images via skopeo (native x86 speed)
#   2. build    — Packer builds the image under QEMU ARM64 emulation
#   3. compress — PiShrink + zerofree + xz compression + checksums
#
# Runner requirements:
#   - Self-hosted runner with privileged Docker executor
#   - volumes: ["/var/run/docker.sock:/var/run/docker.sock", "/dev:/dev"]
#   - qemu-user-static registered on host (binfmt_misc)
#   - DOCKER_AUTH_CONFIG env with GHCR credentials in runner config.toml
# =============================================================================

stages:
  - download
  - build
  - compress

variables:
  CUBEOS_VERSION: "0.1.0-alpha"
  IMAGE_NAME: "cubeos-${CUBEOS_VERSION}-arm64"
  BASE_IMAGE_URL: "https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz"
  BASE_IMAGE_CHECKSUM_URL: "https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz.sha256"

# =============================================================================
# Stage 1: Download ARM64 Docker images at native x86 speed
# =============================================================================
# Skopeo pulls ARM64 manifests natively on x86 — no QEMU emulation needed.
# Images are saved as docker-archive tarballs, passed to Stage 2 as artifacts.
# =============================================================================
download-docker-images:
  stage: download
  image:
    name: quay.io/skopeo/stable:latest
    entrypoint: [""]
  before_script:
    # Bridge GHCR auth from runner's DOCKER_AUTH_CONFIG to skopeo's auth file.
    # The runner injects DOCKER_AUTH_CONFIG as an env var (set in config.toml),
    # but skopeo reads credentials from ~/.docker/config.json or --authfile.
    - mkdir -p ~/.docker
    - echo "${DOCKER_AUTH_CONFIG}" > ~/.docker/config.json
  script:
    - mkdir -p docker-images
    - echo "=== Downloading ARM64 Docker images ==="

    # Public images (Docker Hub — no auth needed)
    - echo "[1/5] Pi-hole..."
    - skopeo copy --override-arch arm64 --override-os linux --retry-times 3 docker://docker.io/pihole/pihole:latest docker-archive:docker-images/pihole.tar:pihole/pihole:latest

    - echo "[2/5] Nginx Proxy Manager..."
    - skopeo copy --override-arch arm64 --override-os linux --retry-times 3 docker://docker.io/jc21/nginx-proxy-manager:latest docker-archive:docker-images/npm.tar:jc21/nginx-proxy-manager:latest

    # Private images (GHCR — auth from ~/.docker/config.json)
    - echo "[3/5] CubeOS API..."
    - skopeo copy --override-arch arm64 --override-os linux --retry-times 3 docker://ghcr.io/cubeos-app/cubeos-api:latest docker-archive:docker-images/cubeos-api.tar:ghcr.io/cubeos-app/cubeos-api:latest

    - echo "[4/5] CubeOS HAL..."
    - skopeo copy --override-arch arm64 --override-os linux --retry-times 3 docker://ghcr.io/cubeos-app/cubeos-hal:latest docker-archive:docker-images/cubeos-hal.tar:ghcr.io/cubeos-app/cubeos-hal:latest

    - echo "[5/5] CubeOS Dashboard..."
    - skopeo copy --override-arch arm64 --override-os linux --retry-times 3 docker://ghcr.io/cubeos-app/cubeos-dashboard:latest docker-archive:docker-images/cubeos-dashboard.tar:ghcr.io/cubeos-app/cubeos-dashboard:latest

    # Summary
    - echo ""
    - echo "=== Download complete ==="
    - ls -lh docker-images/
    - du -sh docker-images/
  artifacts:
    paths:
      - docker-images/
    expire_in: 4 hours

# =============================================================================
# Stage 2: Build image with Packer under QEMU emulation
# =============================================================================
# packer-builder-arm loop-mounts the base Pi OS image, chroots with QEMU
# user-mode emulation, and runs our provisioning scripts inside the chroot.
#
# QEMU binfmt must be registered on the HOST (done once, persists across
# reboots). The runner's privileged mode gives access to /dev/loop*.
#
# NOTE: We do NOT run `docker run multiarch/qemu-user-static` here because:
#   1. The packer image may not have a Docker client
#   2. It's already registered on the host via persistent binfmt_misc
#   3. DinD adds unnecessary complexity and failure modes
# =============================================================================
build-image:
  stage: build
  image:
    name: mkaczanowski/packer-builder-arm:latest
    entrypoint: [""]
  needs:
    - download-docker-images
  script:
    - echo "=== Building CubeOS ${CUBEOS_VERSION} image ==="
    - echo "Base image  ${BASE_IMAGE_URL}"
    - echo "Output      ${IMAGE_NAME}.img"

    # Ensure scripts are executable
    - chmod +x packer/scripts/*.sh firstboot/*.sh

    # Verify QEMU is available (fail fast with clear error)
    - |
      if [ ! -f /proc/sys/fs/binfmt_misc/qemu-aarch64 ]; then
        echo "ERROR: QEMU aarch64 binfmt not registered on host!"
        echo "Fix: ssh to runner host and run:"
        echo "  docker run --rm --privileged multiarch/qemu-user-static --reset -p yes"
        exit 1
      fi
      echo "QEMU aarch64 binfmt: OK"

    # Build the image (single-line to avoid YAML multi-line pitfalls)
    - packer build -var "version=${CUBEOS_VERSION}" -var "base_image_url=${BASE_IMAGE_URL}" -var "base_image_checksum=${BASE_IMAGE_CHECKSUM_URL}" packer/cubeos.pkr.hcl

    # Verify output
    - ls -lh ${IMAGE_NAME}.img
    - echo "=== Image built successfully ==="
  artifacts:
    paths:
      - "${IMAGE_NAME}.img"
    expire_in: 4 hours
  timeout: 45m

# =============================================================================
# Stage 3: Shrink, zero, compress, checksum
# =============================================================================
# PiShrink shrinks the root partition to fit content + small margin, then
# configures the image to auto-expand on first boot. Zerofree fills unused
# blocks with zeros for dramatically better xz compression (~25% ratio).
# =============================================================================
compress-image:
  stage: compress
  image: ubuntu:24.04
  needs:
    - build-image
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq xz-utils e2fsprogs zerofree parted wget kpartx util-linux
  script:
    - echo "=== Compressing ${IMAGE_NAME}.img ==="
    - ls -lh ${IMAGE_NAME}.img

    # ── Step 1: PiShrink — shrink partition, add auto-expand on first boot ──
    - echo "[1/4] Running PiShrink..."
    - wget -q -O pishrink.sh https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh || echo "WARN PiShrink download failed, skipping shrink"
    - |
      if [ -f pishrink.sh ]; then
        chmod +x pishrink.sh
        bash pishrink.sh -s ${IMAGE_NAME}.img || echo "WARN PiShrink failed (non-fatal), continuing with unshrunk image"
      fi

    # ── Step 2: Zerofree — zero unused blocks for better xz compression ─────
    - echo "[2/4] Running zerofree..."
    - |
      LOOPDEV=""
      cleanup_loop() {
        if [ -n "$LOOPDEV" ]; then
          echo "Cleaning up loop device $LOOPDEV"
          losetup -d "$LOOPDEV" 2>/dev/null || true
        fi
      }
      trap cleanup_loop EXIT

      LOOPDEV=$(losetup -fP --show ${IMAGE_NAME}.img)
      echo "Loop device: $LOOPDEV"

      # Wait for partition devices to appear
      sleep 2
      ls -la ${LOOPDEV}p* 2>/dev/null || echo "No partition devices found"

      ROOT_PART="${LOOPDEV}p2"
      if [ -b "$ROOT_PART" ]; then
        echo "Running e2fsck on $ROOT_PART..."
        e2fsck -fy "$ROOT_PART" || true
        echo "Running zerofree on $ROOT_PART..."
        zerofree -v "$ROOT_PART" || echo "WARN zerofree failed (non-fatal)"
      else
        echo "WARN Root partition $ROOT_PART not found, skipping zerofree"
      fi

      losetup -d "$LOOPDEV"
      LOOPDEV=""

    # ── Step 3: XZ compress ─────────────────────────────────────────────────
    - echo "[3/4] Compressing with xz -6 (multi-threaded)..."
    - xz -6 -T0 -v ${IMAGE_NAME}.img

    # ── Step 4: Checksums ───────────────────────────────────────────────────
    - echo "[4/4] Calculating checksums..."
    - sha256sum ${IMAGE_NAME}.img.xz > ${IMAGE_NAME}.img.xz.sha256
    - md5sum ${IMAGE_NAME}.img.xz > ${IMAGE_NAME}.img.xz.md5

    # ── Summary ─────────────────────────────────────────────────────────────
    - echo ""
    - echo "============================================================"
    - echo "  CubeOS Release Artifact"
    - echo "============================================================"
    - echo "  File     ${IMAGE_NAME}.img.xz"
    - echo "  Size     $(du -h ${IMAGE_NAME}.img.xz | cut -f1)"
    - echo "  SHA256   $(cut -d' ' -f1 ${IMAGE_NAME}.img.xz.sha256)"
    - echo "============================================================"
  artifacts:
    paths:
      - "${IMAGE_NAME}.img.xz"
      - "${IMAGE_NAME}.img.xz.sha256"
      - "${IMAGE_NAME}.img.xz.md5"
    expire_in: 30 days
  timeout: 30m

# =============================================================================
# Optional: Create GitLab Release (triggered by tag push only)
# =============================================================================
create-release:
  stage: .post
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - compress-image
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v/'
  script:
    - echo "Creating release for ${CI_COMMIT_TAG}..."
    - CHECKSUM=$(cut -d' ' -f1 ${IMAGE_NAME}.img.xz.sha256)
    - echo "SHA256 ${CHECKSUM}"
  release:
    tag_name: "${CI_COMMIT_TAG}"
    name: "CubeOS ${CI_COMMIT_TAG}"
    description: |
      ## CubeOS ${CI_COMMIT_TAG}

      Flashable ARM64 image for Raspberry Pi 4/5.

      ### Quick Start
      1. Flash the .img.xz to SD card using Raspberry Pi Imager
      2. Boot the Pi
      3. Connect to WiFi AP (check console output for SSID and password)
      4. Open http://cubeos.cube in your browser
      5. Complete the setup wizard

      ### Default Credentials
      - Dashboard: admin / cubeos
      - SSH: key-only (configure in wizard)
    assets:
      links:
        - name: "${IMAGE_NAME}.img.xz"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz"
        - name: "SHA256 Checksum"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/cubeos/${CUBEOS_VERSION}/${IMAGE_NAME}.img.xz.sha256"
